class Constants {
  options;
  default;
  constructor(t, s) {
    this.options = t, this.default = s;
  }
  getOptionsOnArray() {
    return Object.values(this.options);
  }
  getKeysOnArray() {
    return Object.keys(this.options);
  }
  getValue(t) {
    return this.options[t] === void 0 ? this.getDefaultValue() : this.options[t];
  }
  getDefaultValue() {
    return this.options[this.default];
  }
  getDefault() {
    return this.default;
  }
}
const GRID_COLUMNS_MOBILE_CLASS = new Constants(
  {
    1: "sq-grid-cols-1",
    2: "sq-grid-cols-2",
    3: "sq-grid-cols-3",
    4: "sq-grid-cols-4",
    5: "sq-grid-cols-5",
    6: "sq-grid-cols-6"
  },
  2
), GRID_COLUMNS_CLASS = new Constants(
  {
    1: "sm:sq-grid-cols-1",
    2: "sm:sq-grid-cols-2",
    3: "sm:sq-grid-cols-3",
    4: "sm:sq-grid-cols-4",
    5: "sm:sq-grid-cols-5",
    6: "sm:sq-grid-cols-6"
  },
  4
), GRID_TYPE_CLASS = new Constants(
  {
    masonry: "sq-masonry sm:sq-masonry-sm md:sq-masonry-md",
    row: "sm:sq-grid",
    mosaic: "sm:sq-grid sm-sq-mosaic"
  },
  "row"
), GRID_TYPE_MOBILE_CLASS = new Constants(
  {
    masonry: "sq-masonry sq-masonry-sm",
    row: "sq-grid",
    mosaic: "sq-grid sq-mosaic"
  },
  "default"
), TEMPLATES_TYPES = new Constants(
  {
    gallery: "gallery",
    pdp: "product-details",
    report: "report",
    modal_post: "modal_post",
    upload_image: "upload_image",
    teaser: "teaser",
    fullpage_popup: "fullpage-popup"
  },
  "gallery"
), ON_LOAD_ATTR_TYPES = new Constants({ no: "no", loader: "loader", outline: "outline" }, "no"), POPUPS_WIDTH_CLASS = new Constants({ 0: "sq-w-full", 40: "sq-w-2/5", 50: "sq-w-1/2", 60: "sq-w-3/5" }, 50), POST_TYPE = new Constants(
  {
    clean: "clean",
    user: "user",
    full: "full",
    light: "light",
    medium: "medium"
  },
  "clean"
);
function addCustomEventsToSvelteComponent(e) {
  const t = [
    "selectPost",
    "closeModal",
    "selectProduct",
    "nextPost",
    "prevPost",
    "reportImage",
    "uploadImage",
    "uploadImageSuccess",
    "loadMore",
    "onGallery",
    "prevSlide",
    "nextSlide",
    "onClickInstagram",
    "mediaOnLoad",
    "mediaOnVisible",
    "streamOnLoad",
    "streamOnVisible",
    "productOnVisible",
    "prevProductSlide",
    "nextProductSlide"
  ];
  for (const s in t) {
    const i = t[s];
    e.$on(
      i,
      (n) => {
        let a = this._state.streams[n.detail.config.stream].data;
        const r = this._state.defaultLanguage, o = this._state.template;
        switch (n.detail.config.template === "product-details" && a.data.length === 0 && this.getPdpData(e.$$.ctx[0].links.social_api, n.detail.config, (l) => {
          a.data = l;
        }), i) {
          case "selectPost":
            this.trackEvent(
              "media-click",
              {
                mmid: n.detail.post?.id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              n.detail.source ? n.detail.source : o
            ), n.detail.type !== "fullpage-popup" ? this.openModal(
              {
                ...a,
                suuid: a.config.suuid,
                stream: a.config.stream,
                post_id: n.detail.post.fb_id,
                post: n.detail.post
              },
              void 0,
              () => this.trackEvent(
                "media-popup-loaded",
                {
                  mmid: n.detail.post?.id
                },
                null,
                n.detail.config.stream,
                this._state.cookie,
                r,
                o
              )
            ) : this.trackEvent(
              "media-popup-loaded",
              {
                mmid: n.detail.post?.id || n.detail.post?._id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              n.detail.source
            );
            break;
          case "closeModal":
            this.closeModal();
            break;
          case "selectProduct":
            this.trackEvent(
              "product-click",
              {
                mmid: n.detail.media?.id || n.detail.media?._id,
                pid: n.detail?.product_id || Object?.values(n.detail.product)[0].product_id || n.detail.product.product_id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              n.detail.source ? n.detail.source : o
            ), this._handleProductClick({
              ...a,
              product_id: n.detail?.product_id || n.detail.product._id,
              product: n.detail.product || n.detail.media.products[n.detail?.product_id || n.detail.product._id],
              type: n.detail.type
            });
            break;
          case "nextPost":
            this.trackEvent(
              "media-popup-interactions",
              {
                mmid: n.detail.media?.id,
                sint: "slide"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            const l = a.data.findIndex((h) => h.fb_id === n.detail.config.post_id);
            let c = a.data[l + 1];
            c || (c = a.data[0]), a.config.lang = r, this.closeModal(!c), c && new MutationObserver((h, g) => {
              this.openModal(
                {
                  post: c,
                  post_id: c.fb_id,
                  suuid: a.config.suuid,
                  stream: a.config.stream,
                  config: a.config,
                  settings: a.settings
                },
                { x: "100%" }
              ), g.disconnect();
            }).observe(document.querySelector(".sq-modal"), {
              characterData: !1,
              childList: !0,
              attributes: !1
            });
            break;
          case "prevPost":
            this.trackEvent(
              "media-popup-interactions",
              {
                mmid: n.detail.media?.id,
                sint: "slide"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            const u = a.data.findIndex((h) => h.fb_id === n.detail.config.post_id);
            let d = a.data[u + 1];
            d || (d = a.data[0]), this.closeModal(!d), d && new MutationObserver((h, g) => {
              this.openModal(
                {
                  post: d,
                  post_id: d.fb_id,
                  suuid: a.config.suuid,
                  stream: a.config.stream,
                  config: a.config,
                  settings: a.settings
                },
                { x: "-100%" }
              ), g.disconnect();
            }).observe(document.querySelector(".sq-modal"), {
              characterData: !1,
              childList: !0,
              attributes: !1
            });
            break;
          case "reportImage":
            this.trackEvent(
              "stream-interaction",
              {
                sint: "report-modal"
              },
              null,
              n.detail.config.suuid,
              this._state.cookie,
              r,
              o
            ), this.closeModal(), new MutationObserver((h, g) => {
              this.renderReportModal(n.detail.config.suuid, n.detail.config.post_id), g.disconnect();
            }).observe(document.querySelector(".sq-modal"), {
              characterData: !1,
              childList: !0,
              attributes: !1
            });
            break;
          case "uploadImage":
            this.renderUploadModal(n.detail.config.stream);
            break;
          case "uploadImageSuccess":
            this.trackEvent(
              "stream-interaction",
              {
                sint: "frontend-upload"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "loadMore":
            this.trackEvent(
              "stream-interaction",
              {
                sint: "load-more"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "onGallery":
            this.trackEvent(
              "stream-interaction",
              {
                sint: "gallery-link"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "prevSlide":
            this.trackEvent(
              "stream-interaction",
              {
                sint: "slide"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "nextSlide":
            this.trackEvent(
              "stream-interaction",
              {
                sint: "slide"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "onClickInstagram":
            this.trackEvent(
              "media-popup-interactions",
              {
                mmid: n.detail.post?.id,
                pint: "instagram-user-click"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "mediaOnLoad":
            this.trackEvent(
              "media-loaded",
              {
                mmid: n.detail.isMultiple ? [...n.detail.media?.map((h) => h.id)] : n.detail.media?.id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "mediaOnVisible":
            this.trackEvent(
              "media-visible",
              {
                mmid: n.detail.isMultiple ? [...n.detail.media?.map((h) => h.id)] : n.detail.media?.id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "streamOnLoad":
            this.trackEvent(
              "stream-loaded",
              {
                mmid: n.detail.media?.id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "streamOnVisible":
            this.trackEvent(
              "stream-visible",
              {
                mmid: n.detail.media?.id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "productOnVisible":
            this.trackEvent(
              "product-visible",
              {
                mmid: n.detail.media?.id,
                pid: n.detail?.product_id || Object?.values(n.detail.product)[0].product_id
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "prevProductSlide":
            this.trackEvent(
              "media-popup-interactions",
              {
                mmid: n.detail.media?.id,
                pint: "slide-products"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
          case "nextProductSlide":
            this.trackEvent(
              "media-popup-interactions",
              {
                mmid: n.detail.media?.id,
                pint: "slide-products"
              },
              null,
              n.detail.config.stream,
              this._state.cookie,
              r,
              o
            );
            break;
        }
        n.detail.callback && n.detail.callback();
      }
    );
  }
  return e;
}
class Color {
  r = null;
  g = null;
  b = null;
  constructor(t) {
    const s = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    t = t.replace(s, (n, a, r, o) => a + a + r + r + o + o);
    const i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    this.set(parseInt(i[1], 16), parseInt(i[2], 16), parseInt(i[3], 16));
  }
  toString() {
    return `rgb(${Math.round(this.r)}, ${Math.round(this.g)}, ${Math.round(this.b)})`;
  }
  set(t, s, i) {
    this.r = this.clamp(t), this.g = this.clamp(s), this.b = this.clamp(i);
  }
  hueRotate(t = 0) {
    t = t / 180 * Math.PI;
    const s = Math.sin(t), i = Math.cos(t);
    this.multiply([
      0.213 + i * 0.787 - s * 0.213,
      0.715 - i * 0.715 - s * 0.715,
      0.072 - i * 0.072 + s * 0.928,
      0.213 - i * 0.213 + s * 0.143,
      0.715 + i * 0.285 + s * 0.14,
      0.072 - i * 0.072 - s * 0.283,
      0.213 - i * 0.213 - s * 0.787,
      0.715 - i * 0.715 + s * 0.715,
      0.072 + i * 0.928 + s * 0.072
    ]);
  }
  grayscale(t = 1) {
    this.multiply([
      0.2126 + 0.7874 * (1 - t),
      0.7152 - 0.7152 * (1 - t),
      0.0722 - 0.0722 * (1 - t),
      0.2126 - 0.2126 * (1 - t),
      0.7152 + 0.2848 * (1 - t),
      0.0722 - 0.0722 * (1 - t),
      0.2126 - 0.2126 * (1 - t),
      0.7152 - 0.7152 * (1 - t),
      0.0722 + 0.9278 * (1 - t)
    ]);
  }
  sepia(t = 1) {
    this.multiply([
      0.393 + 0.607 * (1 - t),
      0.769 - 0.769 * (1 - t),
      0.189 - 0.189 * (1 - t),
      0.349 - 0.349 * (1 - t),
      0.686 + 0.314 * (1 - t),
      0.168 - 0.168 * (1 - t),
      0.272 - 0.272 * (1 - t),
      0.534 - 0.534 * (1 - t),
      0.131 + 0.869 * (1 - t)
    ]);
  }
  saturate(t = 1) {
    this.multiply([
      0.213 + 0.787 * t,
      0.715 - 0.715 * t,
      0.072 - 0.072 * t,
      0.213 - 0.213 * t,
      0.715 + 0.285 * t,
      0.072 - 0.072 * t,
      0.213 - 0.213 * t,
      0.715 - 0.715 * t,
      0.072 + 0.928 * t
    ]);
  }
  multiply(t) {
    const s = this.clamp(this.r * t[0] + this.g * t[1] + this.b * t[2]), i = this.clamp(this.r * t[3] + this.g * t[4] + this.b * t[5]), n = this.clamp(this.r * t[6] + this.g * t[7] + this.b * t[8]);
    this.r = s, this.g = i, this.b = n;
  }
  brightness(t = 1) {
    this.linear(t);
  }
  contrast(t = 1) {
    this.linear(t, -(0.5 * t) + 0.5);
  }
  linear(t = 1, s = 0) {
    this.r = this.clamp(this.r * t + s * 255), this.g = this.clamp(this.g * t + s * 255), this.b = this.clamp(this.b * t + s * 255);
  }
  invert(t = 1) {
    this.r = this.clamp((t + this.r / 255 * (1 - 2 * t)) * 255), this.g = this.clamp((t + this.g / 255 * (1 - 2 * t)) * 255), this.b = this.clamp((t + this.b / 255 * (1 - 2 * t)) * 255);
  }
  hsl() {
    const t = this.r / 255, s = this.g / 255, i = this.b / 255, n = Math.max(t, s, i), a = Math.min(t, s, i);
    let r, o, l = (n + a) / 2;
    if (n === a)
      r = o = 0;
    else {
      const c = n - a;
      switch (o = l > 0.5 ? c / (2 - n - a) : c / (n + a), n) {
        case t:
          r = (s - i) / c + (s < i ? 6 : 0);
          break;
        case s:
          r = (i - t) / c + 2;
          break;
        case i:
          r = (t - s) / c + 4;
          break;
      }
      r /= 6;
    }
    return {
      h: r * 100,
      s: o * 100,
      l: l * 100
    };
  }
  clamp(t) {
    return t > 255 ? t = 255 : t < 0 && (t = 0), t;
  }
}
class Solver {
  target = null;
  targetHSL = null;
  reusedColor = null;
  constructor(t) {
    this.target = t, this.targetHSL = t.hsl(), this.reusedColor = new Color("#000000");
  }
  solve() {
    const t = this.solveNarrow(this.solveWide());
    return {
      values: t.values,
      loss: t.loss,
      filter: this.css(t.values)
    };
  }
  solveWide() {
    const i = [60, 180, 18e3, 600, 1.2, 1.2];
    let n = { loss: 1 / 0 };
    for (let a = 0; n.loss > 25 && a < 3; a++) {
      const r = [50, 20, 3750, 50, 100, 100], o = this.spsa(5, i, 15, r, 1e3);
      o.loss < n.loss && (n = o);
    }
    return n;
  }
  solveNarrow(t) {
    const s = t.loss, i = 2, n = s + 1, a = [0.25 * n, 0.25 * n, n, 0.25 * n, 0.2 * n, 0.2 * n];
    return this.spsa(s, a, i, t.values, 500);
  }
  spsa(t, s, i, n, a) {
    const o = 0.16666666666666666;
    let l = null, c = 1 / 0;
    const u = new Array(6), d = new Array(6), h = new Array(6);
    for (let p = 0; p < a; p++) {
      const m = i / Math.pow(p + 1, o);
      for (let b = 0; b < 6; b++)
        u[b] = Math.random() > 0.5 ? 1 : -1, d[b] = n[b] + m * u[b], h[b] = n[b] - m * u[b];
      const v = this.loss(d) - this.loss(h);
      for (let b = 0; b < 6; b++) {
        const E = v / (2 * m) * u[b], A = s[b] / Math.pow(t + p + 1, 1);
        n[b] = g(n[b] - A * E, b);
      }
      const f = this.loss(n);
      f < c && (l = n.slice(0), c = f);
    }
    return { values: l, loss: c };
    function g(p, m) {
      let v = 100;
      return m === 2 ? v = 7500 : (m === 4 || m === 5) && (v = 200), m === 3 ? p > v ? p %= v : p < 0 && (p = v + p % v) : p < 0 ? p = 0 : p > v && (p = v), p;
    }
  }
  loss(t) {
    const s = this.reusedColor;
    s.set(0, 0, 0), s.invert(t[0] / 100), s.sepia(t[1] / 100), s.saturate(t[2] / 100), s.hueRotate(t[3] * 3.6), s.brightness(t[4] / 100), s.contrast(t[5] / 100);
    const i = s.hsl();
    return Math.abs(s.r - this.target.r) + Math.abs(s.g - this.target.g) + Math.abs(s.b - this.target.b) + Math.abs(i.h - this.targetHSL.h) + Math.abs(i.s - this.targetHSL.s) + Math.abs(i.l - this.targetHSL.l);
  }
  css(t) {
    function s(i, n = 1) {
      return Math.round(t[i] * n);
    }
    return `filter: invert(${s(0)}%) sepia(${s(1)}%) saturate(${s(2)}%) hue-rotate(${s(
      3,
      3.6
    )}deg) brightness(${s(4)}%) contrast(${s(5)}%);`;
  }
}
function formatStyle(e) {
  const t = {
    "letter-spacing": "px",
    "line-height": "px",
    width: "px",
    "min-width": "px",
    "max-width": "px",
    height: "px",
    "min-height": "px",
    "max-height": "px",
    top: "px",
    bottom: "px",
    left: "px",
    right: "px",
    margin: "px",
    "margin-left": "px",
    "margin-top": "px",
    "margin-bottom": "px",
    "margin-right": "px",
    padding: "px",
    "padding-left": "px",
    "padding-top": "px",
    "padding-bottom": "px",
    "padding-right": "px",
    "border-radius": "px"
  };
  let s = "";
  for (let i in e) {
    let n = t[i] !== void 0 && !e[i]?.includes("px") ? `${e[i]}${t[i]}` : e[i];
    s += `${i}: ${n};`;
  }
  return s;
}
function extractErrors(e) {
  return e.inner.reduce((t, s) => ({ ...t, [s.path]: s.message }), {});
}
function translation(e, t, s) {
  return typeof e == "string" ? JSON.parse(e)[t?.lang] : typeof e == "object" ? s(e) : e;
}
function postHoverType(e) {
  let t = {
    class: "",
    items: []
  };
  if (e) {
    let s = e.split("-");
    for (const i in s)
      switch (s[i]) {
        case "bottom":
          t.class = "sq-justify-end sq-items-start";
          break;
        case "centered":
          t.class = "sq-justify-center sq-items-center sq-text-center";
          break;
        case "justified":
          t.class = " sq-items-center";
          break;
        default:
          if (s[i] === "full") {
            const n = t.items.length - 1;
            t.items[n] = "avatar", t.items.push("user");
          } else
            t.items.push(s[i]);
          break;
      }
  }
  return t;
}
function getButtonStyles(e) {
  return getInlineCss(e?.hover, e?.css, e?.class);
}
function getStylesWithHover(e) {
  const t = e.css, s = e.class;
  let i = {}, n = {};
  if (t && s) {
    for (let a in t)
      a.includes(":hover") ? i[a.replace(":hover", "")] = t[a] : n[a] = t[a];
    if (Object.keys(n).length)
      return getInlineCss(i, n, s);
  }
  return "";
}
function getInlineCss(e, t, s) {
  return `.${s} {${formatStyle(t)}} .${s}:hover {${formatStyle(e)}}`;
}
function _isElementInViewport(e, t, s, i) {
  var n = i || "-10%";
  function a(o, l) {
    var c = o[0];
    c.isIntersecting ? t && typeof t == "function" && t(e, c) : s && typeof s == "function" && s(e, c);
  }
  var r = new IntersectionObserver(a, {
    rootMargin: n
  });
  r.observe(e);
}
function getPostRedirect(e) {
  return e.type !== "fullpage-popup" && (e.product = e.product[e?.lang]), e?.product?.add_to_card_url?.length > 0 ? e?.product?.add_to_card_url : e?.product?.url;
}
function addMediaParams(e, t, s) {
  if (e?.includes(s)) {
    const i = "?tr=";
    if (e.includes(i)) {
      let n = e.split(i)[1]?.split(",");
      n.push(`${t}-${s}`), n = n.join(","), e = e.replace(i + e.split(i)[1].split("/")[0], ""), e = e + i + n;
    } else
      e = e + i + t + "-" + s;
  }
  return e;
}
function formatMansoryItems() {
  let e = [...document.querySelectorAll(".sq-masonry")];
  e.length && getComputedStyle(e[0]).gridTemplateRows !== "masonry" && (e = e.map((t) => ({
    _el: t,
    gap: parseFloat(getComputedStyle(t).gridRowGap),
    items: [...t.childNodes].filter((s) => s.nodeType === 1),
    ncol: 0
  })), e.forEach((t) => {
    let s = getComputedStyle(t._el).gridTemplateColumns.split(" ").length;
    t.ncol !== s && (t.ncol = s, t.items.forEach((i) => i.style.removeProperty("margin-top")), t.ncol > 1 && (t.items.slice(s).forEach((i, n) => {
      let r = t.items[n].querySelector(".sq-post")?.getBoundingClientRect()?.bottom, o = i?.getBoundingClientRect()?.top;
      i.style.marginTop = `${r + t.gap - o}px`;
    }), t.items.forEach((i, n) => i.style.opacity = 1)));
  }));
}
function cssFilter(e) {
  return new Solver(new Color(e)).solve().filter;
}
function removePTag(e) {
  let t;
  return t = e.split(">")[0], e = e.replace(t, ""), e = e.slice(1), e = e.slice(0, -4), e;
}
function getPopupLayoutItems(e) {
  e = e?.includes("product") ? e?.replace("product-", "") : e;
  const t = e, s = t?.split("-")[0], i = t?.split("-")[1];
  return [s, i];
}
function getGridClasses(e) {
  let t = "sq-w-1/2", s = "sq-w-1/2";
  switch (e) {
    case "50x50":
      t = "sq-w-1/2", s = "sq-w-1/2";
      break;
    case "40x60":
      t = "sq-w-2/5", s = "sq-w-3/5";
      break;
    case "60x40":
      t = "sq-w-3/5", s = "sq-w-2/5";
    case "vertical":
      t = "sq-w-full", s = "sq-w-full";
      break;
  }
  return [t, s];
}
function orientationValue(e) {
  let t = e || "center", s = "";
  switch (t) {
    case "right":
      s = "margin-left: auto;";
      break;
    case "left":
      s = "margin-right: auto;";
      break;
    default:
      s = "margin: 0 auto;";
      break;
  }
  return s;
}
function getBluredMedia(e) {
  let t = "";
  t = "tr:bl-10";
  let s = e?.split("/").pop();
  return e = e?.replace(s, ""), e = e + t + "/" + s, e;
}
function isImagekit(e) {
  if (!e)
    return !1;
  const t = "https://";
  return e = e.replace(t, ""), e = e.split("/")[0], e.includes("imagekit");
}
function getCurrencySympol(e) {
  switch (e) {
    case "usd":
      return "$";
    case "eur":
      return "€";
    case "gbp":
      return "£";
    default:
      return e || "";
  }
}
function removeExtraImagekitVideoParams(e) {
  if (e && e.includes(".mp4?tr=")) {
    const t = e.split(".mp4?tr=")[1].split(","), s = [];
    return t.forEach((i) => {
      i.slice(0, 2).toLowerCase() !== "x-" && i.slice(0, 2).toLowerCase() !== "y-" && s.push(i);
    }), e.split(".mp4?tr=")[0] + ".mp4?tr=" + s.join(",");
  } else
    return e;
}
function isJsonString(e) {
  try {
    JSON.parse(e);
  } catch {
    return !1;
  }
  return !0;
}
function noop$1() {
}
const identity = (e) => e;
function assign(e, t) {
  for (const s in t)
    e[s] = t[s];
  return e;
}
function run(e) {
  return e();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(e) {
  e.forEach(run);
}
function is_function(e) {
  return typeof e == "function";
}
function safe_not_equal(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
let src_url_equal_anchor;
function src_url_equal(e, t) {
  return src_url_equal_anchor || (src_url_equal_anchor = document.createElement("a")), src_url_equal_anchor.href = t, e === src_url_equal_anchor.href;
}
function is_empty(e) {
  return Object.keys(e).length === 0;
}
function subscribe(e, ...t) {
  if (e == null)
    return noop$1;
  const s = e.subscribe(...t);
  return s.unsubscribe ? () => s.unsubscribe() : s;
}
function component_subscribe(e, t, s) {
  e.$$.on_destroy.push(subscribe(t, s));
}
function create_slot(e, t, s, i) {
  if (e) {
    const n = get_slot_context(e, t, s, i);
    return e[0](n);
  }
}
function get_slot_context(e, t, s, i) {
  return e[1] && i ? assign(s.ctx.slice(), e[1](i(t))) : s.ctx;
}
function get_slot_changes(e, t, s, i) {
  if (e[2] && i) {
    const n = e[2](i(s));
    if (t.dirty === void 0)
      return n;
    if (typeof n == "object") {
      const a = [], r = Math.max(t.dirty.length, n.length);
      for (let o = 0; o < r; o += 1)
        a[o] = t.dirty[o] | n[o];
      return a;
    }
    return t.dirty | n;
  }
  return t.dirty;
}
function update_slot_base(e, t, s, i, n, a) {
  if (n) {
    const r = get_slot_context(t, s, i, a);
    e.p(r, n);
  }
}
function get_all_dirty_from_scope(e) {
  if (e.ctx.length > 32) {
    const t = [], s = e.ctx.length / 32;
    for (let i = 0; i < s; i++)
      t[i] = -1;
    return t;
  }
  return -1;
}
function action_destroyer(e) {
  return e && is_function(e.destroy) ? e.destroy : noop$1;
}
const is_client = typeof window < "u";
let now$1 = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (e) => requestAnimationFrame(e) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(e) {
  tasks.forEach((t) => {
    t.c(e) || (tasks.delete(t), t.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop$1(e) {
  let t;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((s) => {
      tasks.add(t = { c: e, f: s });
    }),
    abort() {
      tasks.delete(t);
    }
  };
}
function append(e, t) {
  e.appendChild(t);
}
function get_root_for_style(e) {
  if (!e)
    return document;
  const t = e.getRootNode ? e.getRootNode() : e.ownerDocument;
  return t && t.host ? t : e.ownerDocument;
}
function append_empty_stylesheet(e) {
  const t = element("style");
  return append_stylesheet(get_root_for_style(e), t), t.sheet;
}
function append_stylesheet(e, t) {
  return append(e.head || e, t), t.sheet;
}
function insert(e, t, s) {
  e.insertBefore(t, s || null);
}
function detach(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function destroy_each(e, t) {
  for (let s = 0; s < e.length; s += 1)
    e[s] && e[s].d(t);
}
function element(e) {
  return document.createElement(e);
}
function svg_element(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function text(e) {
  return document.createTextNode(e);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(e, t, s, i) {
  return e.addEventListener(t, s, i), () => e.removeEventListener(t, s, i);
}
function attr(e, t, s) {
  s == null ? e.removeAttribute(t) : e.getAttribute(t) !== s && e.setAttribute(t, s);
}
function set_attributes(e, t) {
  const s = Object.getOwnPropertyDescriptors(e.__proto__);
  for (const i in t)
    t[i] == null ? e.removeAttribute(i) : i === "style" ? e.style.cssText = t[i] : i === "__value" ? e.value = e[i] = t[i] : s[i] && s[i].set ? e[i] = t[i] : attr(e, i, t[i]);
}
function set_custom_element_data_map(e, t) {
  Object.keys(t).forEach((s) => {
    set_custom_element_data(e, s, t[s]);
  });
}
function set_custom_element_data(e, t, s) {
  t in e ? e[t] = typeof e[t] == "boolean" && s === "" ? !0 : s : attr(e, t, s);
}
function children(e) {
  return Array.from(e.childNodes);
}
function set_data(e, t) {
  t = "" + t, e.wholeText !== t && (e.data = t);
}
function set_input_value(e, t) {
  e.value = t ?? "";
}
function set_style(e, t, s, i) {
  s === null ? e.style.removeProperty(t) : e.style.setProperty(t, s, i ? "important" : "");
}
function select_option(e, t) {
  for (let s = 0; s < e.options.length; s += 1) {
    const i = e.options[s];
    if (i.__value === t) {
      i.selected = !0;
      return;
    }
  }
  e.selectedIndex = -1;
}
function select_value(e) {
  const t = e.querySelector(":checked") || e.options[0];
  return t && t.__value;
}
let crossorigin;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = !1;
    try {
      typeof window < "u" && window.parent && window.parent.document;
    } catch {
      crossorigin = !0;
    }
  }
  return crossorigin;
}
function add_resize_listener(e, t) {
  getComputedStyle(e).position === "static" && (e.style.position = "relative");
  const i = element("iframe");
  i.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"), i.setAttribute("aria-hidden", "true"), i.tabIndex = -1;
  const n = is_crossorigin();
  let a;
  return n ? (i.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>", a = listen(window, "message", (r) => {
    r.source === i.contentWindow && t();
  })) : (i.src = "about:blank", i.onload = () => {
    a = listen(i.contentWindow, "resize", t);
  }), append(e, i), () => {
    (n || a && i.contentWindow) && a(), detach(i);
  };
}
function toggle_class(e, t, s) {
  e.classList[s ? "add" : "remove"](t);
}
function custom_event(e, t, { bubbles: s = !1, cancelable: i = !1 } = {}) {
  const n = document.createEvent("CustomEvent");
  return n.initCustomEvent(e, s, i, t), n;
}
class HtmlTag {
  constructor(t = !1) {
    this.is_svg = !1, this.is_svg = t, this.e = this.n = null;
  }
  c(t) {
    this.h(t);
  }
  m(t, s, i = null) {
    this.e || (this.is_svg ? this.e = svg_element(s.nodeName) : this.e = element(s.nodeName), this.t = s, this.c(t)), this.i(i);
  }
  h(t) {
    this.e.innerHTML = t, this.n = Array.from(this.e.childNodes);
  }
  i(t) {
    for (let s = 0; s < this.n.length; s += 1)
      insert(this.t, this.n[s], t);
  }
  p(t) {
    this.d(), this.h(t), this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(e, t) {
  return new e(t);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(e) {
  let t = 5381, s = e.length;
  for (; s--; )
    t = (t << 5) - t ^ e.charCodeAt(s);
  return t >>> 0;
}
function create_style_information(e, t) {
  const s = { stylesheet: append_empty_stylesheet(t), rules: {} };
  return managed_styles.set(e, s), s;
}
function create_rule(e, t, s, i, n, a, r, o = 0) {
  const l = 16.666 / i;
  let c = `{
`;
  for (let v = 0; v <= 1; v += l) {
    const f = t + (s - t) * a(v);
    c += v * 100 + `%{${r(f, 1 - f)}}
`;
  }
  const u = c + `100% {${r(s, 1 - s)}}
}`, d = `__svelte_${hash(u)}_${o}`, h = get_root_for_style(e), { stylesheet: g, rules: p } = managed_styles.get(h) || create_style_information(h, e);
  p[d] || (p[d] = !0, g.insertRule(`@keyframes ${d} ${u}`, g.cssRules.length));
  const m = e.style.animation || "";
  return e.style.animation = `${m ? `${m}, ` : ""}${d} ${i}ms linear ${n}ms 1 both`, active += 1, d;
}
function delete_rule(e, t) {
  const s = (e.style.animation || "").split(", "), i = s.filter(
    t ? (a) => a.indexOf(t) < 0 : (a) => a.indexOf("__svelte") === -1
    // remove all Svelte animations
  ), n = s.length - i.length;
  n && (e.style.animation = i.join(", "), active -= n, active || clear_rules());
}
function clear_rules() {
  raf(() => {
    active || (managed_styles.forEach((e) => {
      const { ownerNode: t } = e.stylesheet;
      t && detach(t);
    }), managed_styles.clear());
  });
}
let current_component;
function set_current_component(e) {
  current_component = e;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(e) {
  get_current_component().$$.before_update.push(e);
}
function onMount(e) {
  get_current_component().$$.on_mount.push(e);
}
function createEventDispatcher() {
  const e = get_current_component();
  return (t, s, { cancelable: i = !1 } = {}) => {
    const n = e.$$.callbacks[t];
    if (n) {
      const a = custom_event(t, s, { cancelable: i });
      return n.slice().forEach((r) => {
        r.call(e, a);
      }), !a.defaultPrevented;
    }
    return !0;
  };
}
const dirty_components = [], binding_callbacks = [], render_callbacks = [], flush_callbacks = [], resolved_promise = Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(e) {
  render_callbacks.push(e);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0)
    return;
  const e = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const t = dirty_components[flushidx];
        flushidx++, set_current_component(t), update$1(t.$$);
      }
    } catch (t) {
      throw dirty_components.length = 0, flushidx = 0, t;
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let t = 0; t < render_callbacks.length; t += 1) {
      const s = render_callbacks[t];
      seen_callbacks.has(s) || (seen_callbacks.add(s), s());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(e);
}
function update$1(e) {
  if (e.fragment !== null) {
    e.update(), run_all(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(add_render_callback);
  }
}
let promise;
function wait() {
  return promise || (promise = Promise.resolve(), promise.then(() => {
    promise = null;
  })), promise;
}
function dispatch(e, t, s) {
  e.dispatchEvent(custom_event(`${t ? "intro" : "outro"}${s}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(e, t) {
  e && e.i && (outroing.delete(e), e.i(t));
}
function transition_out(e, t, s, i) {
  if (e && e.o) {
    if (outroing.has(e))
      return;
    outroing.add(e), outros.c.push(() => {
      outroing.delete(e), i && (s && e.d(1), i());
    }), e.o(t);
  } else
    i && i();
}
const null_transition = { duration: 0 };
function create_in_transition(e, t, s) {
  const i = { direction: "in" };
  let n = t(e, s, i), a = !1, r, o, l = 0;
  function c() {
    r && delete_rule(e, r);
  }
  function u() {
    const { delay: h = 0, duration: g = 300, easing: p = identity, tick: m = noop$1, css: v } = n || null_transition;
    v && (r = create_rule(e, 0, 1, g, h, p, v, l++)), m(0, 1);
    const f = now$1() + h, b = f + g;
    o && o.abort(), a = !0, add_render_callback(() => dispatch(e, !0, "start")), o = loop$1((E) => {
      if (a) {
        if (E >= b)
          return m(1, 0), dispatch(e, !0, "end"), c(), a = !1;
        if (E >= f) {
          const A = p((E - f) / g);
          m(A, 1 - A);
        }
      }
      return a;
    });
  }
  let d = !1;
  return {
    start() {
      d || (d = !0, delete_rule(e), is_function(n) ? (n = n(i), wait().then(u)) : u());
    },
    invalidate() {
      d = !1;
    },
    end() {
      a && (c(), a = !1);
    }
  };
}
function create_out_transition(e, t, s) {
  const i = { direction: "out" };
  let n = t(e, s, i), a = !0, r;
  const o = outros;
  o.r += 1;
  function l() {
    const { delay: c = 0, duration: u = 300, easing: d = identity, tick: h = noop$1, css: g } = n || null_transition;
    g && (r = create_rule(e, 1, 0, u, c, d, g));
    const p = now$1() + c, m = p + u;
    add_render_callback(() => dispatch(e, !1, "start")), loop$1((v) => {
      if (a) {
        if (v >= m)
          return h(0, 1), dispatch(e, !1, "end"), --o.r || run_all(o.c), !1;
        if (v >= p) {
          const f = d((v - p) / u);
          h(1 - f, f);
        }
      }
      return a;
    });
  }
  return is_function(n) ? wait().then(() => {
    n = n(i), l();
  }) : l(), {
    end(c) {
      c && n.tick && n.tick(1, 0), a && (r && delete_rule(e, r), a = !1);
    }
  };
}
const globals = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : global;
function destroy_block(e, t) {
  e.d(1), t.delete(e.key);
}
function update_keyed_each(e, t, s, i, n, a, r, o, l, c, u, d) {
  let h = e.length, g = a.length, p = h;
  const m = {};
  for (; p--; )
    m[e[p].key] = p;
  const v = [], f = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map();
  for (p = g; p--; ) {
    const w = d(n, a, p), M = s(w);
    let k = r.get(M);
    k ? i && k.p(w, t) : (k = c(M, w), k.c()), f.set(M, v[p] = k), M in m && b.set(M, Math.abs(p - m[M]));
  }
  const E = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ new Set();
  function C(w) {
    transition_in(w, 1), w.m(o, u), r.set(w.key, w), u = w.first, g--;
  }
  for (; h && g; ) {
    const w = v[g - 1], M = e[h - 1], k = w.key, O = M.key;
    w === M ? (u = w.first, h--, g--) : f.has(O) ? !r.has(k) || E.has(k) ? C(w) : A.has(O) ? h-- : b.get(k) > b.get(O) ? (A.add(k), C(w)) : (E.add(O), h--) : (l(M, r), h--);
  }
  for (; h--; ) {
    const w = e[h];
    f.has(w.key) || l(w, r);
  }
  for (; g; )
    C(v[g - 1]);
  return v;
}
function get_spread_update(e, t) {
  const s = {}, i = {}, n = { $$scope: 1 };
  let a = e.length;
  for (; a--; ) {
    const r = e[a], o = t[a];
    if (o) {
      for (const l in r)
        l in o || (i[l] = 1);
      for (const l in o)
        n[l] || (s[l] = o[l], n[l] = 1);
      e[a] = o;
    } else
      for (const l in r)
        n[l] = 1;
  }
  for (const r in i)
    r in s || (s[r] = void 0);
  return s;
}
function get_spread_object(e) {
  return typeof e == "object" && e !== null ? e : {};
}
function create_component(e) {
  e && e.c();
}
function mount_component(e, t, s, i) {
  const { fragment: n, after_update: a } = e.$$;
  n && n.m(t, s), i || add_render_callback(() => {
    const r = e.$$.on_mount.map(run).filter(is_function);
    e.$$.on_destroy ? e.$$.on_destroy.push(...r) : run_all(r), e.$$.on_mount = [];
  }), a.forEach(add_render_callback);
}
function destroy_component(e, t) {
  const s = e.$$;
  s.fragment !== null && (run_all(s.on_destroy), s.fragment && s.fragment.d(t), s.on_destroy = s.fragment = null, s.ctx = []);
}
function make_dirty(e, t) {
  e.$$.dirty[0] === -1 && (dirty_components.push(e), schedule_update(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function init(e, t, s, i, n, a, r, o = [-1]) {
  const l = current_component;
  set_current_component(e);
  const c = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: a,
    update: noop$1,
    not_equal: n,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (l ? l.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: o,
    skip_bound: !1,
    root: t.target || l.$$.root
  };
  r && r(c.root);
  let u = !1;
  if (c.ctx = s ? s(e, t.props || {}, (d, h, ...g) => {
    const p = g.length ? g[0] : h;
    return c.ctx && n(c.ctx[d], c.ctx[d] = p) && (!c.skip_bound && c.bound[d] && c.bound[d](p), u && make_dirty(e, d)), h;
  }) : [], c.update(), u = !0, run_all(c.before_update), c.fragment = i ? i(c.ctx) : !1, t.target) {
    if (t.hydrate) {
      const d = children(t.target);
      c.fragment && c.fragment.l(d), d.forEach(detach);
    } else
      c.fragment && c.fragment.c();
    t.intro && transition_in(e.$$.fragment), mount_component(e, t.target, t.anchor, t.customElement), flush();
  }
  set_current_component(l);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$1;
  }
  $on(t, s) {
    if (!is_function(s))
      return noop$1;
    const i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return i.push(s), () => {
      const n = i.indexOf(s);
      n !== -1 && i.splice(n, 1);
    };
  }
  $set(t) {
    this.$$set && !is_empty(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
class BaseComponent {
  app;
  data;
  App;
  addEvents;
  beforeDestroy;
  constructor(t, s) {
    this.addEvents = s, this.App = t;
  }
  /*
   * Remove the component and run onDestroy function of Svelte before of clean html content.
   */
  _destroy() {
    this.app && this.app.$$.fragment && (group_outros(), transition_out(this.app.$$.fragment, 0, 0, () => {
      this.app.$destroy(), this.beforeDestroy && this.beforeDestroy(), this.app = null;
    }), check_outros());
  }
  /*
   * Create the svelte component, and add the custom events.
   */
  async _create(t, s) {
    const i = new this.App({
      target: t,
      props: s
    });
    this.app = await this.addEvents(i), this.data = s;
  }
}
class Modal extends BaseComponent {
  wrapper;
  wrapperOverlay;
  overlay;
  /*
   * Get or create a div to wrap the modal component
   */
  createModalContainerIsNotExist(t) {
    this.wrapper || (this.wrapper = document.createElement("div"), this.wrapper.classList.add("sq-modal"), t.template === "modal_post" && (this.wrapperOverlay = document.createElement("div"), this.wrapperOverlay.classList.add("sq-modal-overlay"), setTimeout(() => {
      var s = document.getElementById("sq-popup-main-full-content"), i = s.offsetHeight;
      this.wrapperOverlay.style.height = i - 0.1 + "px", this.wrapperOverlay.style["border-radius"] = t?.settings?.popup?.css["border-radius"] + "px";
    }, 200)), this.overlay = document.createElement("div"), this.overlay.classList.add("sq-fixed"), this.overlay.classList.add("sq-inset-0"), this.overlay.classList.add("sq-bg-[#00000080]"), this.overlay.classList.add("sq-z-[99999]"), this.overlay.addEventListener("click", () => {
      window.history.replaceState(null, "", window.location.href.split("#")[0]), this.destroy();
    }));
  }
  /*
   * Create the report post modal component.
   */
  openReportModal(t, s) {
    this.render({ ...t, template: "report" });
  }
  /*
   * Create the post modal component.
   */
  openPostModal(t) {
    this.render({
      ...t,
      languages: {},
      template: "modal_post"
    });
  }
  /*
   * Create the upload media modal component.
   */
  openUploadMediaModal(t) {
    this.render({ ...t, template: "upload_image" });
  }
  /*
   * Render the svelte element on the DOM, and add the custom events.
   */
  async render(t) {
    this.createModalContainerIsNotExist(t), this._create(this.wrapper, t), document.body.appendChild(this.overlay), (t.template === "modal_post" || t.template === "report") && this.wrapperOverlay ? this.overlay.appendChild(this.wrapperOverlay) : this.wrapperOverlay && this.overlay.removeChild(this.wrapperOverlay), this.overlay.appendChild(this.wrapper), document.body.style.overflow = "hidden", setTimeout(() => {
      const s = document.getElementById("sq-popup-main-full-content");
      console.log(s), s && s.addEventListener("click", (i) => {
        i.stopPropagation();
      });
    }, 400);
  }
  /*
   * Clean the modal container (HTML element)
   */
  removeModalContainer() {
    this.overlay?.remove(), document.body.style.overflow = "visible";
  }
  /*
   * Remove the component and run the onDestroy function of Svelte before clean html content,
   * and create a before function to remove the modal container.
   */
  destroy(t = !0) {
    this.beforeDestroy = () => t ? this.removeModalContainer() : null, this._destroy();
  }
  /*
   * Returns the value to check if the modal is displayed or not (for end-user use).
   */
  get isDisplayed() {
    return this.app !== null;
  }
}
function bind(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString } = Object.prototype, { getPrototypeOf } = Object, kindOf = ((e) => (t) => {
  const s = toString.call(t);
  return e[s] || (e[s] = s.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (e) => (e = e.toLowerCase(), (t) => kindOf(t) === e), typeOfTest = (e) => (t) => typeof t === e, { isArray } = Array, isUndefined = typeOfTest("undefined");
function isBuffer(e) {
  return e !== null && !isUndefined(e) && e.constructor !== null && !isUndefined(e.constructor) && isFunction(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && isArrayBuffer(e.buffer), t;
}
const isString = typeOfTest("string"), isFunction = typeOfTest("function"), isNumber = typeOfTest("number"), isObject$3 = (e) => e !== null && typeof e == "object", isBoolean = (e) => e === !0 || e === !1, isPlainObject = (e) => {
  if (kindOf(e) !== "object")
    return !1;
  const t = getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (e) => isObject$3(e) && isFunction(e.pipe), isFormData = (e) => {
  const t = "[object FormData]";
  return e && (typeof FormData == "function" && e instanceof FormData || toString.call(e) === t || isFunction(e.toString) && e.toString() === t);
}, isURLSearchParams = kindOfTest("URLSearchParams"), trim = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(e, t, { allOwnKeys: s = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let i, n;
  if (typeof e != "object" && (e = [e]), isArray(e))
    for (i = 0, n = e.length; i < n; i++)
      t.call(null, e[i], i, e);
  else {
    const a = s ? Object.getOwnPropertyNames(e) : Object.keys(e), r = a.length;
    let o;
    for (i = 0; i < r; i++)
      o = a[i], t.call(null, e[o], o, e);
  }
}
function findKey(e, t) {
  t = t.toLowerCase();
  const s = Object.keys(e);
  let i = s.length, n;
  for (; i-- > 0; )
    if (n = s[i], t === n.toLowerCase())
      return n;
  return null;
}
const _global = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), isContextDefined = (e) => !isUndefined(e) && e !== _global;
function merge() {
  const { caseless: e } = isContextDefined(this) && this || {}, t = {}, s = (i, n) => {
    const a = e && findKey(t, n) || n;
    isPlainObject(t[a]) && isPlainObject(i) ? t[a] = merge(t[a], i) : isPlainObject(i) ? t[a] = merge({}, i) : isArray(i) ? t[a] = i.slice() : t[a] = i;
  };
  for (let i = 0, n = arguments.length; i < n; i++)
    arguments[i] && forEach(arguments[i], s);
  return t;
}
const extend$3 = (e, t, s, { allOwnKeys: i } = {}) => (forEach(t, (n, a) => {
  s && isFunction(n) ? e[a] = bind(n, s) : e[a] = n;
}, { allOwnKeys: i }), e), stripBOM = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), inherits = (e, t, s, i) => {
  e.prototype = Object.create(t.prototype, i), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), s && Object.assign(e.prototype, s);
}, toFlatObject = (e, t, s, i) => {
  let n, a, r;
  const o = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (n = Object.getOwnPropertyNames(e), a = n.length; a-- > 0; )
      r = n[a], (!i || i(r, e, t)) && !o[r] && (t[r] = e[r], o[r] = !0);
    e = s !== !1 && getPrototypeOf(e);
  } while (e && (!s || s(e, t)) && e !== Object.prototype);
  return t;
}, endsWith = (e, t, s) => {
  e = String(e), (s === void 0 || s > e.length) && (s = e.length), s -= t.length;
  const i = e.indexOf(t, s);
  return i !== -1 && i === s;
}, toArray = (e) => {
  if (!e)
    return null;
  if (isArray(e))
    return e;
  let t = e.length;
  if (!isNumber(t))
    return null;
  const s = new Array(t);
  for (; t-- > 0; )
    s[t] = e[t];
  return s;
}, isTypedArray = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (e, t) => {
  const i = (e && e[Symbol.iterator]).call(e);
  let n;
  for (; (n = i.next()) && !n.done; ) {
    const a = n.value;
    t.call(e, a[0], a[1]);
  }
}, matchAll = (e, t) => {
  let s;
  const i = [];
  for (; (s = e.exec(t)) !== null; )
    i.push(s);
  return i;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(s, i, n) {
    return i.toUpperCase() + n;
  }
), hasOwnProperty = (({ hasOwnProperty: e }) => (t, s) => e.call(t, s))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (e, t) => {
  const s = Object.getOwnPropertyDescriptors(e), i = {};
  forEach(s, (n, a) => {
    t(n, a, e) !== !1 && (i[a] = n);
  }), Object.defineProperties(e, i);
}, freezeMethods = (e) => {
  reduceDescriptors(e, (t, s) => {
    if (isFunction(e) && ["arguments", "caller", "callee"].indexOf(s) !== -1)
      return !1;
    const i = e[s];
    if (isFunction(i)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + s + "'");
      });
    }
  });
}, toObjectSet = (e, t) => {
  const s = {}, i = (n) => {
    n.forEach((a) => {
      s[a] = !0;
    });
  };
  return isArray(e) ? i(e) : i(String(e).split(t)), s;
}, noop = () => {
}, toFiniteNumber = (e, t) => (e = +e, Number.isFinite(e) ? e : t), ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = (e = 16, t = ALPHABET.ALPHA_DIGIT) => {
  let s = "";
  const { length: i } = t;
  for (; e--; )
    s += t[Math.random() * i | 0];
  return s;
};
function isSpecCompliantForm(e) {
  return !!(e && isFunction(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const toJSONObject = (e) => {
  const t = new Array(10), s = (i, n) => {
    if (isObject$3(i)) {
      if (t.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        t[n] = i;
        const a = isArray(i) ? [] : {};
        return forEach(i, (r, o) => {
          const l = s(r, n + 1);
          !isUndefined(l) && (a[o] = l);
        }), t[n] = void 0, a;
      }
    }
    return i;
  };
  return s(e, 0);
}, utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$3,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend: extend$3,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};
function AxiosError(e, t, s, i, n) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), s && (this.config = s), i && (this.request = i), n && (this.response = n);
}
utils.inherits(AxiosError, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  descriptors[e] = { value: e };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (e, t, s, i, n, a) => {
  const r = Object.create(prototype$1);
  return utils.toFlatObject(e, r, function(l) {
    return l !== Error.prototype;
  }, (o) => o !== "isAxiosError"), AxiosError.call(r, e.message, t, s, i, n), r.cause = e, r.name = e.name, a && Object.assign(r, a), r;
};
const httpAdapter = null;
function isVisitable(e) {
  return utils.isPlainObject(e) || utils.isArray(e);
}
function removeBrackets(e) {
  return utils.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function renderKey(e, t, s) {
  return e ? e.concat(t).map(function(n, a) {
    return n = removeBrackets(n), !s && a ? "[" + n + "]" : n;
  }).join(s ? "." : "") : t;
}
function isFlatArray(e) {
  return utils.isArray(e) && !e.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function toFormData(e, t, s) {
  if (!utils.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), s = utils.toFlatObject(s, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, v) {
    return !utils.isUndefined(v[m]);
  });
  const i = s.metaTokens, n = s.visitor || u, a = s.dots, r = s.indexes, l = (s.Blob || typeof Blob < "u" && Blob) && utils.isSpecCompliantForm(t);
  if (!utils.isFunction(n))
    throw new TypeError("visitor must be a function");
  function c(p) {
    if (p === null)
      return "";
    if (utils.isDate(p))
      return p.toISOString();
    if (!l && utils.isBlob(p))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils.isArrayBuffer(p) || utils.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p;
  }
  function u(p, m, v) {
    let f = p;
    if (p && !v && typeof p == "object") {
      if (utils.endsWith(m, "{}"))
        m = i ? m : m.slice(0, -2), p = JSON.stringify(p);
      else if (utils.isArray(p) && isFlatArray(p) || (utils.isFileList(p) || utils.endsWith(m, "[]")) && (f = utils.toArray(p)))
        return m = removeBrackets(m), f.forEach(function(E, A) {
          !(utils.isUndefined(E) || E === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            r === !0 ? renderKey([m], A, a) : r === null ? m : m + "[]",
            c(E)
          );
        }), !1;
    }
    return isVisitable(p) ? !0 : (t.append(renderKey(v, m, a), c(p)), !1);
  }
  const d = [], h = Object.assign(predicates, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable
  });
  function g(p, m) {
    if (!utils.isUndefined(p)) {
      if (d.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      d.push(p), utils.forEach(p, function(f, b) {
        (!(utils.isUndefined(f) || f === null) && n.call(
          t,
          f,
          utils.isString(b) ? b.trim() : b,
          m,
          h
        )) === !0 && g(f, m ? m.concat(b) : [b]);
      }), d.pop();
    }
  }
  if (!utils.isObject(e))
    throw new TypeError("data must be an object");
  return g(e), t;
}
function encode$1(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(i) {
    return t[i];
  });
}
function AxiosURLSearchParams(e, t) {
  this._pairs = [], e && toFormData(e, this, t);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function(t, s) {
  this._pairs.push([t, s]);
};
prototype.toString = function(t) {
  const s = t ? function(i) {
    return t.call(this, i, encode$1);
  } : encode$1;
  return this._pairs.map(function(n) {
    return s(n[0]) + "=" + s(n[1]);
  }, "").join("&");
};
function encode(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(e, t, s) {
  if (!t)
    return e;
  const i = s && s.encode || encode, n = s && s.serialize;
  let a;
  if (n ? a = n(t, s) : a = utils.isURLSearchParams(t) ? t.toString() : new AxiosURLSearchParams(t, s).toString(i), a) {
    const r = e.indexOf("#");
    r !== -1 && (e = e.slice(0, r)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, s, i) {
    return this.handlers.push({
      fulfilled: t,
      rejected: s,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    utils.forEach(this.handlers, function(i) {
      i !== null && t(i);
    });
  }
}
const InterceptorManager$1 = InterceptorManager, transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, isStandardBrowserEnv = (() => {
  let e;
  return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), isStandardBrowserWebWorkerEnv = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), platform = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(e, t) {
  return toFormData(e, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(s, i, n, a) {
      return platform.isNode && utils.isBuffer(s) ? (this.append(i, s.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function parsePropPath(e) {
  return utils.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function arrayToObject(e) {
  const t = {}, s = Object.keys(e);
  let i;
  const n = s.length;
  let a;
  for (i = 0; i < n; i++)
    a = s[i], t[a] = e[a];
  return t;
}
function formDataToJSON(e) {
  function t(s, i, n, a) {
    let r = s[a++];
    const o = Number.isFinite(+r), l = a >= s.length;
    return r = !r && utils.isArray(n) ? n.length : r, l ? (utils.hasOwnProp(n, r) ? n[r] = [n[r], i] : n[r] = i, !o) : ((!n[r] || !utils.isObject(n[r])) && (n[r] = []), t(s, i, n[r], a) && utils.isArray(n[r]) && (n[r] = arrayToObject(n[r])), !o);
  }
  if (utils.isFormData(e) && utils.isFunction(e.entries)) {
    const s = {};
    return utils.forEachEntry(e, (i, n) => {
      t(parsePropPath(i), n, s, 0);
    }), s;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(e, t, s) {
  if (utils.isString(e))
    try {
      return (t || JSON.parse)(e), utils.trim(e);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (s || JSON.stringify)(e);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, s) {
    const i = s.getContentType() || "", n = i.indexOf("application/json") > -1, a = utils.isObject(t);
    if (a && utils.isHTMLForm(t) && (t = new FormData(t)), utils.isFormData(t))
      return n && n ? JSON.stringify(formDataToJSON(t)) : t;
    if (utils.isArrayBuffer(t) || utils.isBuffer(t) || utils.isStream(t) || utils.isFile(t) || utils.isBlob(t))
      return t;
    if (utils.isArrayBufferView(t))
      return t.buffer;
    if (utils.isURLSearchParams(t))
      return s.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let o;
    if (a) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(t, this.formSerializer).toString();
      if ((o = utils.isFileList(t)) || i.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return toFormData(
          o ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return a || n ? (s.setContentType("application/json", !1), stringifySafely(t)) : t;
  }],
  transformResponse: [function(t) {
    const s = this.transitional || defaults$1.transitional, i = s && s.forcedJSONParsing, n = this.responseType === "json";
    if (t && utils.isString(t) && (i && !this.responseType || n)) {
      const r = !(s && s.silentJSONParsing) && n;
      try {
        return JSON.parse(t);
      } catch (o) {
        if (r)
          throw o.name === "SyntaxError" ? AxiosError.from(o, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function(t) {
  defaults$1.headers[t] = {};
});
utils.forEach(["post", "put", "patch"], function(t) {
  defaults$1.headers[t] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$2 = defaults$1, ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (e) => {
  const t = {};
  let s, i, n;
  return e && e.split(`
`).forEach(function(r) {
    n = r.indexOf(":"), s = r.substring(0, n).trim().toLowerCase(), i = r.substring(n + 1).trim(), !(!s || t[s] && ignoreDuplicateOf[s]) && (s === "set-cookie" ? t[s] ? t[s].push(i) : t[s] = [i] : t[s] = t[s] ? t[s] + ", " + i : i);
  }), t;
}, $internals = Symbol("internals");
function normalizeHeader(e) {
  return e && String(e).trim().toLowerCase();
}
function normalizeValue(e) {
  return e === !1 || e == null ? e : utils.isArray(e) ? e.map(normalizeValue) : String(e);
}
function parseTokens(e) {
  const t = /* @__PURE__ */ Object.create(null), s = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = s.exec(e); )
    t[i[1]] = i[2];
  return t;
}
function isValidHeaderName(e) {
  return /^[-_a-zA-Z]+$/.test(e.trim());
}
function matchHeaderValue(e, t, s, i, n) {
  if (utils.isFunction(i))
    return i.call(this, t, s);
  if (n && (t = s), !!utils.isString(t)) {
    if (utils.isString(i))
      return t.indexOf(i) !== -1;
    if (utils.isRegExp(i))
      return i.test(t);
  }
}
function formatHeader(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, s, i) => s.toUpperCase() + i);
}
function buildAccessors(e, t) {
  const s = utils.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(e, i + s, {
      value: function(n, a, r) {
        return this[i].call(this, t, n, a, r);
      },
      configurable: !0
    });
  });
}
class AxiosHeaders {
  constructor(t) {
    t && this.set(t);
  }
  set(t, s, i) {
    const n = this;
    function a(o, l, c) {
      const u = normalizeHeader(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = utils.findKey(n, u);
      (!d || n[d] === void 0 || c === !0 || c === void 0 && n[d] !== !1) && (n[d || l] = normalizeValue(o));
    }
    const r = (o, l) => utils.forEach(o, (c, u) => a(c, u, l));
    return utils.isPlainObject(t) || t instanceof this.constructor ? r(t, s) : utils.isString(t) && (t = t.trim()) && !isValidHeaderName(t) ? r(parseHeaders(t), s) : t != null && a(s, t, i), this;
  }
  get(t, s) {
    if (t = normalizeHeader(t), t) {
      const i = utils.findKey(this, t);
      if (i) {
        const n = this[i];
        if (!s)
          return n;
        if (s === !0)
          return parseTokens(n);
        if (utils.isFunction(s))
          return s.call(this, n, i);
        if (utils.isRegExp(s))
          return s.exec(n);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, s) {
    if (t = normalizeHeader(t), t) {
      const i = utils.findKey(this, t);
      return !!(i && this[i] !== void 0 && (!s || matchHeaderValue(this, this[i], i, s)));
    }
    return !1;
  }
  delete(t, s) {
    const i = this;
    let n = !1;
    function a(r) {
      if (r = normalizeHeader(r), r) {
        const o = utils.findKey(i, r);
        o && (!s || matchHeaderValue(i, i[o], o, s)) && (delete i[o], n = !0);
      }
    }
    return utils.isArray(t) ? t.forEach(a) : a(t), n;
  }
  clear(t) {
    const s = Object.keys(this);
    let i = s.length, n = !1;
    for (; i--; ) {
      const a = s[i];
      (!t || matchHeaderValue(this, this[a], a, t, !0)) && (delete this[a], n = !0);
    }
    return n;
  }
  normalize(t) {
    const s = this, i = {};
    return utils.forEach(this, (n, a) => {
      const r = utils.findKey(i, a);
      if (r) {
        s[r] = normalizeValue(n), delete s[a];
        return;
      }
      const o = t ? formatHeader(a) : String(a).trim();
      o !== a && delete s[a], s[o] = normalizeValue(n), i[o] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const s = /* @__PURE__ */ Object.create(null);
    return utils.forEach(this, (i, n) => {
      i != null && i !== !1 && (s[n] = t && utils.isArray(i) ? i.join(", ") : i);
    }), s;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, s]) => t + ": " + s).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...s) {
    const i = new this(t);
    return s.forEach((n) => i.set(n)), i;
  }
  static accessor(t) {
    const i = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function a(r) {
      const o = normalizeHeader(r);
      i[o] || (buildAccessors(n, r), i[o] = !0);
    }
    return utils.isArray(t) ? t.forEach(a) : a(t), this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(e, t) {
  const s = this || defaults$2, i = t || s, n = AxiosHeaders$1.from(i.headers);
  let a = i.data;
  return utils.forEach(e, function(o) {
    a = o.call(s, a, n.normalize(), t ? t.status : void 0);
  }), n.normalize(), a;
}
function isCancel(e) {
  return !!(e && e.__CANCEL__);
}
function CanceledError(e, t, s) {
  AxiosError.call(this, e ?? "canceled", AxiosError.ERR_CANCELED, t, s), this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: !0
});
function settle(e, t, s) {
  const i = s.config.validateStatus;
  !s.status || !i || i(s.status) ? e(s) : t(new AxiosError(
    "Request failed with status code " + s.status,
    [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(s.status / 100) - 4],
    s.config,
    s.request,
    s
  ));
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(s, i, n, a, r, o) {
        const l = [];
        l.push(s + "=" + encodeURIComponent(i)), utils.isNumber(n) && l.push("expires=" + new Date(n).toGMTString()), utils.isString(a) && l.push("path=" + a), utils.isString(r) && l.push("domain=" + r), o === !0 && l.push("secure"), document.cookie = l.join("; ");
      },
      read: function(s) {
        const i = document.cookie.match(new RegExp("(^|;\\s*)(" + s + ")=([^;]*)"));
        return i ? decodeURIComponent(i[3]) : null;
      },
      remove: function(s) {
        this.write(s, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function isAbsoluteURL(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function combineURLs(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function buildFullPath(e, t) {
  return e && !isAbsoluteURL(t) ? combineURLs(e, t) : t;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), s = document.createElement("a");
    let i;
    function n(a) {
      let r = a;
      return t && (s.setAttribute("href", r), r = s.href), s.setAttribute("href", r), {
        href: s.href,
        protocol: s.protocol ? s.protocol.replace(/:$/, "") : "",
        host: s.host,
        search: s.search ? s.search.replace(/^\?/, "") : "",
        hash: s.hash ? s.hash.replace(/^#/, "") : "",
        hostname: s.hostname,
        port: s.port,
        pathname: s.pathname.charAt(0) === "/" ? s.pathname : "/" + s.pathname
      };
    }
    return i = n(window.location.href), function(r) {
      const o = utils.isString(r) ? n(r) : r;
      return o.protocol === i.protocol && o.host === i.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function parseProtocol(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function speedometer(e, t) {
  e = e || 10;
  const s = new Array(e), i = new Array(e);
  let n = 0, a = 0, r;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = i[a];
    r || (r = c), s[n] = l, i[n] = c;
    let d = a, h = 0;
    for (; d !== n; )
      h += s[d++], d = d % e;
    if (n = (n + 1) % e, n === a && (a = (a + 1) % e), c - r < t)
      return;
    const g = u && c - u;
    return g ? Math.round(h * 1e3 / g) : void 0;
  };
}
function progressEventReducer(e, t) {
  let s = 0;
  const i = speedometer(50, 250);
  return (n) => {
    const a = n.loaded, r = n.lengthComputable ? n.total : void 0, o = a - s, l = i(o), c = a <= r;
    s = a;
    const u = {
      loaded: a,
      total: r,
      progress: r ? a / r : void 0,
      bytes: o,
      rate: l || void 0,
      estimated: l && r && c ? (r - a) / l : void 0,
      event: n
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(e) {
  return new Promise(function(s, i) {
    let n = e.data;
    const a = AxiosHeaders$1.from(e.headers).normalize(), r = e.responseType;
    let o;
    function l() {
      e.cancelToken && e.cancelToken.unsubscribe(o), e.signal && e.signal.removeEventListener("abort", o);
    }
    utils.isFormData(n) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) && a.setContentType(!1);
    let c = new XMLHttpRequest();
    if (e.auth) {
      const g = e.auth.username || "", p = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      a.set("Authorization", "Basic " + btoa(g + ":" + p));
    }
    const u = buildFullPath(e.baseURL, e.url);
    c.open(e.method.toUpperCase(), buildURL(u, e.params, e.paramsSerializer), !0), c.timeout = e.timeout;
    function d() {
      if (!c)
        return;
      const g = AxiosHeaders$1.from(
        "getAllResponseHeaders" in c && c.getAllResponseHeaders()
      ), m = {
        data: !r || r === "text" || r === "json" ? c.responseText : c.response,
        status: c.status,
        statusText: c.statusText,
        headers: g,
        config: e,
        request: c
      };
      settle(function(f) {
        s(f), l();
      }, function(f) {
        i(f), l();
      }, m), c = null;
    }
    if ("onloadend" in c ? c.onloadend = d : c.onreadystatechange = function() {
      !c || c.readyState !== 4 || c.status === 0 && !(c.responseURL && c.responseURL.indexOf("file:") === 0) || setTimeout(d);
    }, c.onabort = function() {
      c && (i(new AxiosError("Request aborted", AxiosError.ECONNABORTED, e, c)), c = null);
    }, c.onerror = function() {
      i(new AxiosError("Network Error", AxiosError.ERR_NETWORK, e, c)), c = null;
    }, c.ontimeout = function() {
      let p = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const m = e.transitional || transitionalDefaults;
      e.timeoutErrorMessage && (p = e.timeoutErrorMessage), i(new AxiosError(
        p,
        m.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        e,
        c
      )), c = null;
    }, platform.isStandardBrowserEnv) {
      const g = (e.withCredentials || isURLSameOrigin(u)) && e.xsrfCookieName && cookies.read(e.xsrfCookieName);
      g && a.set(e.xsrfHeaderName, g);
    }
    n === void 0 && a.setContentType(null), "setRequestHeader" in c && utils.forEach(a.toJSON(), function(p, m) {
      c.setRequestHeader(m, p);
    }), utils.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), r && r !== "json" && (c.responseType = e.responseType), typeof e.onDownloadProgress == "function" && c.addEventListener("progress", progressEventReducer(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && c.upload && c.upload.addEventListener("progress", progressEventReducer(e.onUploadProgress)), (e.cancelToken || e.signal) && (o = (g) => {
      c && (i(!g || g.type ? new CanceledError(null, e, c) : g), c.abort(), c = null);
    }, e.cancelToken && e.cancelToken.subscribe(o), e.signal && (e.signal.aborted ? o() : e.signal.addEventListener("abort", o)));
    const h = parseProtocol(u);
    if (h && platform.protocols.indexOf(h) === -1) {
      i(new AxiosError("Unsupported protocol " + h + ":", AxiosError.ERR_BAD_REQUEST, e));
      return;
    }
    c.send(n || null);
  });
}, knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const adapters = {
  getAdapter: (e) => {
    e = utils.isArray(e) ? e : [e];
    const { length: t } = e;
    let s, i;
    for (let n = 0; n < t && (s = e[n], !(i = utils.isString(s) ? knownAdapters[s.toLowerCase()] : s)); n++)
      ;
    if (!i)
      throw i === !1 ? new AxiosError(
        `Adapter ${s} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        utils.hasOwnProp(knownAdapters, s) ? `Adapter '${s}' is not available in the build` : `Unknown adapter '${s}'`
      );
    if (!utils.isFunction(i))
      throw new TypeError("adapter is not a function");
    return i;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new CanceledError(null, e);
}
function dispatchRequest(e) {
  return throwIfCancellationRequested(e), e.headers = AxiosHeaders$1.from(e.headers), e.data = transformData.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(e.adapter || defaults$2.adapter)(e).then(function(i) {
    return throwIfCancellationRequested(e), i.data = transformData.call(
      e,
      e.transformResponse,
      i
    ), i.headers = AxiosHeaders$1.from(i.headers), i;
  }, function(i) {
    return isCancel(i) || (throwIfCancellationRequested(e), i && i.response && (i.response.data = transformData.call(
      e,
      e.transformResponse,
      i.response
    ), i.response.headers = AxiosHeaders$1.from(i.response.headers))), Promise.reject(i);
  });
}
const headersToObject = (e) => e instanceof AxiosHeaders$1 ? e.toJSON() : e;
function mergeConfig(e, t) {
  t = t || {};
  const s = {};
  function i(c, u, d) {
    return utils.isPlainObject(c) && utils.isPlainObject(u) ? utils.merge.call({ caseless: d }, c, u) : utils.isPlainObject(u) ? utils.merge({}, u) : utils.isArray(u) ? u.slice() : u;
  }
  function n(c, u, d) {
    if (utils.isUndefined(u)) {
      if (!utils.isUndefined(c))
        return i(void 0, c, d);
    } else
      return i(c, u, d);
  }
  function a(c, u) {
    if (!utils.isUndefined(u))
      return i(void 0, u);
  }
  function r(c, u) {
    if (utils.isUndefined(u)) {
      if (!utils.isUndefined(c))
        return i(void 0, c);
    } else
      return i(void 0, u);
  }
  function o(c, u, d) {
    if (d in t)
      return i(c, u);
    if (d in e)
      return i(void 0, c);
  }
  const l = {
    url: a,
    method: a,
    data: a,
    baseURL: r,
    transformRequest: r,
    transformResponse: r,
    paramsSerializer: r,
    timeout: r,
    timeoutMessage: r,
    withCredentials: r,
    adapter: r,
    responseType: r,
    xsrfCookieName: r,
    xsrfHeaderName: r,
    onUploadProgress: r,
    onDownloadProgress: r,
    decompress: r,
    maxContentLength: r,
    maxBodyLength: r,
    beforeRedirect: r,
    transport: r,
    httpAgent: r,
    httpsAgent: r,
    cancelToken: r,
    socketPath: r,
    responseEncoding: r,
    validateStatus: o,
    headers: (c, u) => n(headersToObject(c), headersToObject(u), !0)
  };
  return utils.forEach(Object.keys(e).concat(Object.keys(t)), function(u) {
    const d = l[u] || n, h = d(e[u], t[u], u);
    utils.isUndefined(h) && d !== o || (s[u] = h);
  }), s;
}
const VERSION = "1.3.3", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  validators$1[e] = function(i) {
    return typeof i === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function(t, s, i) {
  function n(a, r) {
    return "[Axios v" + VERSION + "] Transitional option '" + a + "'" + r + (i ? ". " + i : "");
  }
  return (a, r, o) => {
    if (t === !1)
      throw new AxiosError(
        n(r, " has been removed" + (s ? " in " + s : "")),
        AxiosError.ERR_DEPRECATED
      );
    return s && !deprecatedWarnings[r] && (deprecatedWarnings[r] = !0, console.warn(
      n(
        r,
        " has been deprecated since v" + s + " and will be removed in the near future"
      )
    )), t ? t(a, r, o) : !0;
  };
};
function assertOptions(e, t, s) {
  if (typeof e != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(e);
  let n = i.length;
  for (; n-- > 0; ) {
    const a = i[n], r = t[a];
    if (r) {
      const o = e[a], l = o === void 0 || r(o, a, e);
      if (l !== !0)
        throw new AxiosError("option " + a + " must be " + l, AxiosError.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (s !== !0)
      throw new AxiosError("Unknown option " + a, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions,
  validators: validators$1
}, validators = validator.validators;
class Axios {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, s) {
    typeof t == "string" ? (s = s || {}, s.url = t) : s = t || {}, s = mergeConfig(this.defaults, s);
    const { transitional: i, paramsSerializer: n, headers: a } = s;
    i !== void 0 && validator.assertOptions(i, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), n !== void 0 && validator.assertOptions(n, {
      encode: validators.function,
      serialize: validators.function
    }, !0), s.method = (s.method || this.defaults.method || "get").toLowerCase();
    let r;
    r = a && utils.merge(
      a.common,
      a[s.method]
    ), r && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (p) => {
        delete a[p];
      }
    ), s.headers = AxiosHeaders$1.concat(r, a);
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(s) === !1 || (l = l && m.synchronous, o.unshift(m.fulfilled, m.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(m) {
      c.push(m.fulfilled, m.rejected);
    });
    let u, d = 0, h;
    if (!l) {
      const p = [dispatchRequest.bind(this), void 0];
      for (p.unshift.apply(p, o), p.push.apply(p, c), h = p.length, u = Promise.resolve(s); d < h; )
        u = u.then(p[d++], p[d++]);
      return u;
    }
    h = o.length;
    let g = s;
    for (d = 0; d < h; ) {
      const p = o[d++], m = o[d++];
      try {
        g = p(g);
      } catch (v) {
        m.call(this, v);
        break;
      }
    }
    try {
      u = dispatchRequest.call(this, g);
    } catch (p) {
      return Promise.reject(p);
    }
    for (d = 0, h = c.length; d < h; )
      u = u.then(c[d++], c[d++]);
    return u;
  }
  getUri(t) {
    t = mergeConfig(this.defaults, t);
    const s = buildFullPath(t.baseURL, t.url);
    return buildURL(s, t.params, t.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function(t) {
  Axios.prototype[t] = function(s, i) {
    return this.request(mergeConfig(i || {}, {
      method: t,
      url: s,
      data: (i || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function(t) {
  function s(i) {
    return function(a, r, o) {
      return this.request(mergeConfig(o || {}, {
        method: t,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: r
      }));
    };
  }
  Axios.prototype[t] = s(), Axios.prototype[t + "Form"] = s(!0);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let s;
    this.promise = new Promise(function(a) {
      s = a;
    });
    const i = this;
    this.promise.then((n) => {
      if (!i._listeners)
        return;
      let a = i._listeners.length;
      for (; a-- > 0; )
        i._listeners[a](n);
      i._listeners = null;
    }), this.promise.then = (n) => {
      let a;
      const r = new Promise((o) => {
        i.subscribe(o), a = o;
      }).then(n);
      return r.cancel = function() {
        i.unsubscribe(a);
      }, r;
    }, t(function(a, r, o) {
      i.reason || (i.reason = new CanceledError(a, r, o), s(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const s = this._listeners.indexOf(t);
    s !== -1 && this._listeners.splice(s, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new CancelToken(function(n) {
        t = n;
      }),
      cancel: t
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(e) {
  return function(s) {
    return e.apply(null, s);
  };
}
function isAxiosError(e) {
  return utils.isObject(e) && e.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([e, t]) => {
  HttpStatusCode[t] = e;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(e) {
  const t = new Axios$1(e), s = bind(Axios$1.prototype.request, t);
  return utils.extend(s, Axios$1.prototype, t, { allOwnKeys: !0 }), utils.extend(s, t, null, { allOwnKeys: !0 }), s.create = function(n) {
    return createInstance(mergeConfig(e, n));
  }, s;
}
const axios = createInstance(defaults$2);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function(t) {
  return Promise.all(t);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (e) => formDataToJSON(utils.isHTMLForm(e) ? new FormData(e) : e);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
class Stream extends BaseComponent {
  /*
   * Send a request to obtain the stream data,and parse data to render in a svelte component.
   */
  showCompoment(t, s, i, n) {
    axios$1.get(`${t}`).then(async (a) => {
      const r = a.data;
      await this.render(i, {
        ...s,
        language: s.lang ?? r?.default_language ?? "de_de",
        languages: r?.languages ?? {},
        ...r
      }), n(r);
    }).catch((a) => console.error(a));
  }
  /*
   * Render svelte element, and add the custom events.
   */
  async render(t, s) {
    await this._create(t, s);
  }
  /*
   * Remove the component and run the onDestroy function of Svelte before clean html content.
   */
  destroy() {
    this._destroy();
  }
}
class Tracking {
  _config;
  _preEventCallbacks;
  _postEventCallbacks;
  cookieless = null;
  aflHash = null;
  cookie = null;
  imported = null;
  cookieName = "sqlvn_cuuid";
  cookieToken = null;
  tokenTry = 0;
  /*
   * Save the configuration data in the object.
   */
  constructor(t) {
    this._config = t;
  }
  /*
   * Build, and send the post request to tracking repository.
   */
  async makePostTrackRequest(t, s, i, n = (r) => console.info(r), a = !1) {
    const r = {
      headers: {
        Authorization: `Bearer ${this.getBrowserCookieByName("sqlvn_event_token")}`
      },
      data: t
    };
    this.cookie && (t.cuuid = this.cookie), this.getBrowserCookieByName("sqlvn_event_token") && axios$1.post(`${this._config.trackingServerUrl}/api/ugc/add-event/`, t, r).then((o) => {
      n(o);
    }).catch((o) => {
      console.error(o), a && this.makePostTrackRequest(t, s, i, n, !1);
    });
  }
  /*
   * Track an event, execute the pre events and post events,
   * and send a request with the tracking data.
   */
  async trackEvent(t, s, i, n = null, a = null, r = null, o = null) {
    this.cookieless === !1 || this.cookie === null || (this._preEventCallbacks?.[t] && this._preEventCallbacks[t].forEach((l) => l()), o === "product-details" && (o = "pdp"), this.makePostTrackRequest(
      Object.assign(s, {
        suuid: n,
        subuuid: i,
        event: t,
        cuuid: a,
        dlang: r,
        mmid: s.mmid ?? null,
        pid: s.pid ?? null,
        st: o
      }),
      i,
      n,
      () => {
        this._postEventCallbacks?.[t] && this._postEventCallbacks[t].forEach((l) => l());
      }
    ));
  }
  /*
   * Get the cookie token, and refresh if is necessary.
   */
  async getCookieToken(t) {
    if (this.tokenTry < 2 && !this.getBrowserCookieByName("sqlvn_event_token"))
      axios$1.get(`${this._config.trackingServerUrl}/api/token?suuid=${t}`).then((s) => {
        this.tokenTry = 0;
        const i = 30 * 60;
        return document.cookie = `sqlvn_event_token=${s.data.token};max-age=${i};path=/`, s.data.token;
      }).catch((s) => {
        s.response.status === 400 ? (this.tokenTry++, this.getCookieToken(t)) : console.error(s);
      }).finally(() => {
      });
    else
      return this.getBrowserCookieByName("sqlvn_event_token");
  }
  /*
   * Add pre-event callback to tracking functionality.
   */
  async addPreEventCallback(t, s) {
    this._preEventCallbacks[t] = this._preEventCallbacks[t] || [], this._preEventCallbacks[t].push(s);
  }
  /*
   * Add post-event callback to tracking functionality.
   */
  async addPostEventCallback(t, s) {
    this._postEventCallbacks[t] = this._postEventCallbacks[t] || [], this._postEventCallbacks[t].push(s);
  }
  /*
   * Generate custom ID for the tracking functionality.
   */
  generateID() {
    let t = 16, s = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = i.length;
    for (let a = 0; a < t; a++)
      s += i.charAt(Math.floor(Math.random() * n));
    return s;
  }
  /*
   * Get Cookie value from browser.
   */
  getCookie() {
    let t = `${this.cookieName}=`, s = document.cookie.split(";");
    for (let i = 0; i < s.length; i++) {
      let n = s[i];
      for (; n.charAt(0) == " "; )
        n = n.substring(1);
      if (n.indexOf(t) == 0)
        return n.substring(t.length, n.length);
    }
    return null;
  }
  getBrowserCookieByName(t) {
    let s = document.cookie.split(";");
    for (let i = 0; i < s?.length; i++) {
      let n = s[i]?.split(";")[0];
      if (n = n?.replace(" ", ""), n?.split("=")[0] === t)
        return n?.split("=")[1];
    }
  }
  /*
   *  Get value from object by dot notation.
   */
  getObjectValueByDotNotation(t, s) {
    let i = t;
    return s.split(".").forEach((n) => {
      i = i[n] || `Property ${n} not found`;
    }), i;
  }
  /*
   *  Check cookie accepted by user.
   */
  CheckCookieAccepted(t, s = null, i = null) {
    let n = "", a = "", r = "";
    if (s === "influencer") {
      const d = {
        headers: {
          Authorization: `Bearer ${this.getBrowserCookieByName("sqlvn_event_token")}`
        }
      };
      axios$1.get(`${this._config.mainServerUrl}/api/influencers/subscription/${i}/cookies`, d).then((h) => {
        const g = h.data.data;
        n = g?.cookies_name, a = g?.cookies_accepting_value, r = g?.cookies_key;
      }).catch((h) => {
        console.error(h);
      });
    } else
      n = t?.cookies_name, a = t?.cookies_accepting_value, r = t?.cookies_key;
    if (!n)
      return !1;
    const o = this.getBrowserCookieByName(n);
    let l = null, c = a;
    const u = JSON.parse(o);
    return typeof u == "object" ? l = this.getObjectValueByDotNotation(u, r) : l = o, String(l) === String(c);
  }
  /*
   *  Set Cookie value on browser.
   */
  setCookie(t, s) {
    const n = this.CheckCookieAccepted(s) ? t : "";
    this.cookie = n, this.CheckCookieAccepted(s) && (document.cookie = `${this.cookieName}=${n};max-age=${604800};path=/`);
  }
  /*
   *  Get subscription uuid from script & call convertion endpoint.
   */
  async conversion(t, s, i) {
    let n;
    if (document.querySelectorAll("script[data-sq-sub]").forEach((a) => (n = a.dataset.sqSub, !1)), n) {
      if (!await this.getCookieToken(n) && !this.getBrowserCookieByName("sqlvn_event_token"))
        setTimeout(() => {
          this.conversion(t, s, i);
        }, 2e3);
      else if (this.getBrowserCookieByName("sqlvn_event_token")) {
        if (t === "influencer" && window.location.search && this.CheckCookieAccepted(i.subscriptionSetting, t, n)) {
          const c = new URLSearchParams(window.location.search).get("sqlvn_affid");
          c && (document.cookie = `sqlvn_affid=${c};max-age=${604800};path=/`);
        }
        const r = {
          headers: {
            Authorization: `Bearer ${this.getBrowserCookieByName("sqlvn_event_token")}`
          },
          conversion: s
        };
        let o = {
          oid: s.oid,
          event: "conversion",
          cuuid: this.getBrowserCookieByName(this.cookieName) || null,
          price: s.price,
          cur: s.cur,
          pids: s.pids,
          dlang: s.dlang,
          type: t,
          clid: s.clid,
          coupon: s.coupon,
          subuuid: n
        };
        if (t === "influencer") {
          const l = {
            affid: s.affid || this.getBrowserCookieByName("sqlvn_affid")
          };
          o = { ...o, ...l };
        }
        this.cookie && (o.cuuid = this.cookie), this.CallConversion(o, r);
      }
    }
  }
  /*
   *  Call convertion endpoint.
   */
  async CallConversion(t, s) {
    axios$1.post(`${this._config.trackingServerUrl}/api/add-conversion/`, t, s).then((i) => {
    }).catch((i) => {
      console.error(i);
    });
  }
}
class Squarelovin {
  _state = {
    urlHashActive: !0,
    defaultLanguage: null,
    suuid: null,
    subuuid: null,
    cuuid: null,
    streams: {},
    subscriptionSetting: {},
    productClickFunction: void 0,
    template: null
  };
  _config = {
    env: "develop",
    serverUrl: "http://127.0.0.1:8000/sdk/sdk/",
    dataServerUrl: "https://squarelovin-main-app.s3.eu-central-1.amazonaws.com/delivery/streams",
    trackingServerUrl: "https://tracking-api.squarelovin.dev",
    reportMediaUrl: "https://staging-social.squarelovin.dev/api/frontend/media/report",
    frontendUploadUrl: "https://staging-social.squarelovin.dev/api/frontend/media",
    fileUploaderUrl: "https://fileuploader.squarelovin.dev/api/multi-upload",
    mainServerUrl: "https://staging.squarelovin.dev"
  };
  tracking = new Tracking(this._config);
  environment = {
    addEventsFunc: addCustomEventsToSvelteComponent.bind(this)
  };
  _dom = {
    head: document.querySelector("head")
  };
  /*
   * Read the DOM,and render all components.
   */
  constructor(e = () => {
  }) {
    const s = new URLSearchParams(window.location.search).get("sqlvn_affid");
    s && (document.cookie = `sqlvn_affid=${s};max-age=${604800};path=/`), (async () => (this.environment.app = (await import("./app.min.js").then((i) => i.a)).default, this._state.modal = new Modal(this.environment.app, this.environment.addEventsFunc), document.querySelectorAll("[data-sq-container]").forEach((i) => this._initializeContainer(i)), e()))();
  }
  /*
   * Checks the data of the selected container and execute the functionality depending on the data
   * (equal to "no" renders when looking at the container, different from "loader" renders the svelte component).
   */
  async _initializeContainer(e) {
    const t = e, s = t.dataset.sqImportOnLoad, i = t.dataset.sqContainer, n = t.dataset.sqTemplate, a = t.dataset.sqStream, r = t.dataset.sqLang, o = t.dataset.sqSub, l = t.dataset.sqProduct, c = {
      suuid: i,
      subuuid: o,
      stream: a,
      template: n,
      productId: l,
      target: t,
      lang: r
    };
    await this.getCookieToken(o), !(!i || !o || !a || !n) && (s !== ON_LOAD_ATTR_TYPES.getValue("loader") && this._renderComponent(c), s === ON_LOAD_ATTR_TYPES.getValue("no") && _isElementInViewport(
      t,
      () => {
        let u = {};
        n === "product-details" && (u = {
          pid: l
        }), this._renderComponent(c), this.trackEvent("stream-visible", u, o, a, this._state.cuuid, r, n);
      },
      () => {
      },
      "-5px"
    ));
  }
  /*
   * Render a component on the DOM (Gallery, Teaser, or Modal)
   */
  async _renderComponent({ suuid: e, subuuid: t, productId: s, stream: i, template: n, target: a, lang: r }) {
    if (this._state.suuid = e, this._state.subuuid = t, !this._state.streams[i]) {
      this._state.streams[i] = new Stream(this.environment.app, this.environment.addEventsFunc), this._state.defaultLanguage = r, this._state.template = n, this.importStyleFile();
      const o = i.includes("”") ? i.slice(1, -1) : i;
      let l = n.includes("”") ? n.slice(1, -1) : n;
      n === "fullpage-popup" && (l = "gallery");
      let c = {};
      n === "product-details" && (c = {
        pid: s
      }), n !== "fullpage-popup" && setTimeout(() => {
        this.trackEvent("stream-loaded", c, t, i, this._state.cuuid, r, n);
      }, 1e3), this._state.streams[i].showCompoment(
        `${this._config.dataServerUrl}/${o}/${l}.json`,
        {
          config: {
            suuid: e,
            subuuid: t,
            stream: i,
            productId: s,
            template: n,
            lang: r,
            serverUrl: this._config.serverUrl,
            dataServerUrl: this._config.dataServerUrl,
            trackingServerUrl: this._config.trackingServerUrl,
            reportMediaUrl: this._config.reportMediaUrl,
            frontendUploadUrl: this._config.frontendUploadUrl,
            fileUploaderUrl: this._config.fileUploaderUrl
          },
          lang: r
        },
        a,
        (u) => {
          this._state.subscriptionSetting = u.subscription_settings, this._state.defaultLanguage && (this._state.defaultLanguage = r ?? u?.default_language);
        }
      ), n !== "fullpage-popup" && setTimeout(() => {
        this.trackEvent("stream-visible", c, t, i, this._state.cuuid, r, n);
      }, 1e3);
    }
  }
  /*
   * Check if the user set a custom handle click, to the products.
   */
  _handleProductClick(props) {
    if (!this._state.streams[props.config.stream])
      return;
    const container = this._state.streams[props.config.stream].app.$$.root, onClick = container.dataset.sqClickOnProductFunction;
    switch (typeof this._state.productClickFunction) {
      case "string":
        eval(this._state.productClickFunction)(props, container);
        break;
      case "function":
        this._state.productClickFunction(props, container);
        break;
      default:
        const redirect = getPostRedirect(props);
        onClick ? eval(onClick)(props, container) : redirect?.length > 0 && (window.location.href = redirect);
        break;
    }
  }
  /*
   * Adds the version to the script tag to avoid caching problems
   */
  addVersionToScripts() {
    let e = `${this._config.serverUrl}squarelovin.min.js`;
    e = e.includes("127.0.0.1") ? e.replace("127.0.0.1", "localhost") : e;
    const t = "1.0.0";
    if (document.querySelector(`script[src='${e}']`)) {
      const s = document.querySelector(`script[src='${e}']`);
      s.parentNode.removeChild(s);
      const i = document.createElement("script");
      i.type = "module", i.src = e + "?v=" + t, this._dom.head.appendChild(i);
    }
  }
  /*
   * Import all external files of a stream. (for end-user use)
   */
  importStyleFile() {
    const e = `${this._config.serverUrl}/squarelovin.min.css`;
    if (!document.querySelector(`link[href='${e}']`)) {
      const t = document.createElement("link");
      t.rel = "stylesheet", t.type = "text/css", t.href = e, this._dom.head.appendChild(t);
    }
  }
  /*
   * Load a stream component on the DOM. (for end-user use)
   */
  loadStream(e) {
    const t = document.querySelector(e.target_class);
    if (t) {
      const { suuid: s, subuuid: i, productId: n, stream: a, template: r, lang: o } = e;
      this._renderComponent({
        suuid: s,
        subuuid: i,
        productId: n,
        stream: a,
        template: r,
        target: t,
        lang: o
      });
      let l = {};
      r === "product-details" && (l = {
        pid: n
      }), _isElementInViewport(
        t,
        () => this.trackEvent("stream-visible", l, i, a, this._state.cuuid, o, r),
        () => {
        },
        "-5px"
      );
    } else
      window.alert("Provided DOM-Node does not exist for querySelector " + e.target_class);
  }
  /*
   * Destroy a svelte component by the stream ID. (for end-user use)
   */
  destroy(e) {
    e && this._state.streams[e].app !== void 0 && this._state.streams[e].destroy();
  }
  /*
   * Render a post item modal. (for end-user use)
   */
  async openModal(e, t = void 0, s = () => {
  }) {
    const i = this._state.streams[e.stream].data.data.findIndex((n) => n.fb_id === e.post.fb_id);
    this._state.urlHashActive && window.history.replaceState(null, "", `#sq-pop-${e.post_id}`), this._state.modal.openPostModal({
      ...e,
      data: e.post,
      lang: e.lang ?? this._state?.defaultLanguage ?? "de_de",
      config: {
        ...this._config,
        post_id: e.post_id,
        stream: e.stream,
        suuid: e.suuid,
        productId: e.productId,
        template: e.template,
        lang: e.config.lang,
        subuuid: this._state.subuuid,
        inTransitions: t,
        key: i,
        total_elements: this._state.streams[e.stream].data.data.length
      }
    }), s();
  }
  /*
   * Render the report modal. (for end-user use)
   */
  async renderReportModal() {
    this._state.modal.openReportModal(this._state.modal.data, this._state.subuuid);
  }
  /*
   * Render the upload image modal. (for end-user use)
   */
  async renderUploadModal(e) {
    this._state.modal.openUploadMediaModal(this._state.streams[e].data);
  }
  /*
   * Close/Destroy modal that is active. (for end-user use)
   */
  async closeModal(e = !0) {
    this._state.urlHashActive && window.history.replaceState(null, "", window.location.href.split("#")[0]), await this._state.modal.destroy(e);
  }
  /*
   * Get url hash option value. (for end-user use)
   */
  get useHash() {
    return this._state.urlHashActive;
  }
  /*
   * Get custom function of product click event. (for end-user use)
   */
  get functionOnProductclick() {
    return this._state.productClickFunction ? this._state.productClickFunction : this._handleProductClick;
  }
  /*
   * Set url hash value, if is active the url will modify when the user click a post item. (for end-user use)
   */
  set useHash(e) {
    this._state.urlHashActive = e;
  }
  /*
   * Set custom function of product click event. (for end-user use)
   */
  set functionOnProductclick(e) {
    this._state.productClickFunction = e;
  }
  /*
   * Track a custom event. (for end-user use)
   */
  async trackEvent(e, t = {}, s, i, n, a, r) {
    const o = i || this._state.suuid, l = this.getCookie(), c = a || this._state.dlang, u = s || this._state.subuuid;
    this.tracking.trackEvent(e, t, u, o, l, c, r);
  }
  async getCookieToken(e) {
    this.tracking.getCookieToken(e);
  }
  async getPdpData(e, t, s) {
    axios$1.post(`${e}/delivery/products`, {
      subscription_uuid: t.subuuid,
      language: t.lang,
      ids: [t.productId]
    }).then((i) => {
      s(i.data.data);
    }).catch((i) => {
      console.error(i);
    }).finally(() => {
    });
  }
  /*
   * Add pre-event callback to tracking functionality. (for end-user use)
   */
  async addPreEventCallback(e, t) {
    this.tracking.addPreEventCallback(e, t);
  }
  /*
   * Add post-event callback to tracking functionality. (for end-user use)
   */
  async addPostEventCallback(e, t) {
    this.tracking.addPostEventCallback(e, t);
  }
  /*
   * Toggle tracker functionality. (for end-user use)
   */
  toogleTracker() {
    this.tracking.cookieless = !this.tracking.cookieless, this.tracking.cookieless === !0 && this.setCookie(this.generateID());
  }
  /*
   * Set AFL-Hash token. (for end-user use)
   */
  setAflHash(e) {
    this.tracking.aflHash = e;
  }
  /*
   * Set Cookie value in the tracking object and in browser. (for end-user use)
   */
  setCookie(e) {
    setTimeout(() => {
      this.tracking.setCookie(e, this._state.subscriptionSetting);
    }, 500);
  }
  /*
   * Get Cookie value. (for end-user use)
   */
  getCookie() {
    return this.tracking.getCookie();
  }
  /*
   * Get AFL-Hash token. (for end-user use)
   */
  get aflHash() {
    return this.tracking.aflHash;
  }
  /*
   * Get Cookie name. (for end-user use)
   */
  get cookie() {
    return this.tracking.cookie;
  }
  /*
   * If the tracking functionality it's active. (for end-user use)
   */
  get isTracking() {
    return this.tracking.cookieless;
  }
  /*
   * Generate custom ID for the tracking functionality. (for end-user use)
   */
  generateID() {
    return this.tracking.generateID();
  }
  /*
   * Convertion tracking functionality.
   */
  conversion(e, t) {
    this.tracking.conversion(e, t, this._state);
  }
}
function isObject$2(e) {
  return e !== null && typeof e == "object" && "constructor" in e && e.constructor === Object;
}
function extend$2(e = {}, t = {}) {
  Object.keys(t).forEach((s) => {
    typeof e[s] > "u" ? e[s] = t[s] : isObject$2(t[s]) && isObject$2(e[s]) && Object.keys(t[s]).length > 0 && extend$2(e[s], t[s]);
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const e = typeof document < "u" ? document : {};
  return extend$2(e, ssrDocument), e;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function e() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(e) {
    return typeof setTimeout > "u" ? (e(), null) : setTimeout(e, 0);
  },
  cancelAnimationFrame(e) {
    typeof setTimeout > "u" || clearTimeout(e);
  }
};
function getWindow() {
  const e = typeof window < "u" ? window : {};
  return extend$2(e, ssrWindow), e;
}
function deleteProps(e) {
  const t = e;
  Object.keys(t).forEach((s) => {
    try {
      t[s] = null;
    } catch {
    }
    try {
      delete t[s];
    } catch {
    }
  });
}
function nextTick(e, t = 0) {
  return setTimeout(e, t);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(e) {
  const t = getWindow();
  let s;
  return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s;
}
function getTranslate(e, t = "x") {
  const s = getWindow();
  let i, n, a;
  const r = getComputedStyle$1(e);
  return s.WebKitCSSMatrix ? (n = r.transform || r.webkitTransform, n.split(",").length > 6 && (n = n.split(", ").map((o) => o.replace(",", ".")).join(", ")), a = new s.WebKitCSSMatrix(n === "none" ? "" : n)) : (a = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = a.toString().split(",")), t === "x" && (s.WebKitCSSMatrix ? n = a.m41 : i.length === 16 ? n = parseFloat(i[12]) : n = parseFloat(i[4])), t === "y" && (s.WebKitCSSMatrix ? n = a.m42 : i.length === 16 ? n = parseFloat(i[13]) : n = parseFloat(i[5])), n || 0;
}
function isObject$1(e) {
  return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object";
}
function isNode(e) {
  return typeof window < "u" && typeof window.HTMLElement < "u" ? e instanceof HTMLElement : e && (e.nodeType === 1 || e.nodeType === 11);
}
function extend$1(...e) {
  const t = Object(e[0]), s = ["__proto__", "constructor", "prototype"];
  for (let i = 1; i < e.length; i += 1) {
    const n = e[i];
    if (n != null && !isNode(n)) {
      const a = Object.keys(Object(n)).filter((r) => s.indexOf(r) < 0);
      for (let r = 0, o = a.length; r < o; r += 1) {
        const l = a[r], c = Object.getOwnPropertyDescriptor(n, l);
        c !== void 0 && c.enumerable && (isObject$1(t[l]) && isObject$1(n[l]) ? n[l].__swiper__ ? t[l] = n[l] : extend$1(t[l], n[l]) : !isObject$1(t[l]) && isObject$1(n[l]) ? (t[l] = {}, n[l].__swiper__ ? t[l] = n[l] : extend$1(t[l], n[l])) : t[l] = n[l]);
      }
    }
  }
  return t;
}
function setCSSProperty(e, t, s) {
  e.style.setProperty(t, s);
}
function animateCSSModeScroll({
  swiper: e,
  targetPosition: t,
  side: s
}) {
  const i = getWindow(), n = -e.translate;
  let a = null, r;
  const o = e.params.speed;
  e.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(e.cssModeFrameID);
  const l = t > n ? "next" : "prev", c = (d, h) => l === "next" && d >= h || l === "prev" && d <= h, u = () => {
    r = new Date().getTime(), a === null && (a = r);
    const d = Math.max(Math.min((r - a) / o, 1), 0), h = 0.5 - Math.cos(d * Math.PI) / 2;
    let g = n + h * (t - n);
    if (c(g, t) && (g = t), e.wrapperEl.scrollTo({
      [s]: g
    }), c(g, t)) {
      e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
        e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
          [s]: g
        });
      }), i.cancelAnimationFrame(e.cssModeFrameID);
      return;
    }
    e.cssModeFrameID = i.requestAnimationFrame(u);
  };
  u();
}
function getSlideTransformEl(e) {
  return e.querySelector(".swiper-slide-transform") || e.shadowEl && e.shadowEl.querySelector(".swiper-slide-transform") || e;
}
function elementChildren(e, t = "") {
  return [...e.children].filter((s) => s.matches(t));
}
function createElement(e, t = []) {
  const s = document.createElement(e);
  return s.classList.add(...Array.isArray(t) ? t : [t]), s;
}
function elementOffset(e) {
  const t = getWindow(), s = getDocument(), i = e.getBoundingClientRect(), n = s.body, a = e.clientTop || n.clientTop || 0, r = e.clientLeft || n.clientLeft || 0, o = e === t ? t.scrollY : e.scrollTop, l = e === t ? t.scrollX : e.scrollLeft;
  return {
    top: i.top + o - a,
    left: i.left + l - r
  };
}
function elementPrevAll(e, t) {
  const s = [];
  for (; e.previousElementSibling; ) {
    const i = e.previousElementSibling;
    t ? i.matches(t) && s.push(i) : s.push(i), e = i;
  }
  return s;
}
function elementNextAll(e, t) {
  const s = [];
  for (; e.nextElementSibling; ) {
    const i = e.nextElementSibling;
    t ? i.matches(t) && s.push(i) : s.push(i), e = i;
  }
  return s;
}
function elementStyle(e, t) {
  return getWindow().getComputedStyle(e, null).getPropertyValue(t);
}
function elementIndex(e) {
  let t = e, s;
  if (t) {
    for (s = 0; (t = t.previousSibling) !== null; )
      t.nodeType === 1 && (s += 1);
    return s;
  }
}
function elementParents(e, t) {
  const s = [];
  let i = e.parentElement;
  for (; i; )
    t ? i.matches(t) && s.push(i) : s.push(i), i = i.parentElement;
  return s;
}
function elementTransitionEnd(e, t) {
  function s(i) {
    i.target === e && (t.call(e, i), e.removeEventListener("transitionend", s));
  }
  t && e.addEventListener("transitionend", s);
}
function elementOuterSize(e, t, s) {
  const i = getWindow();
  return s ? e[t === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(e, null).getPropertyValue(t === "width" ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(e, null).getPropertyValue(t === "width" ? "margin-left" : "margin-bottom")) : e.offsetWidth;
}
let support;
function calcSupport() {
  const e = getWindow(), t = getDocument();
  return {
    smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
    touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch)
  };
}
function getSupport() {
  return support || (support = calcSupport()), support;
}
let deviceCached;
function calcDevice({
  userAgent: e
} = {}) {
  const t = getSupport(), s = getWindow(), i = s.navigator.platform, n = e || s.navigator.userAgent, a = {
    ios: !1,
    android: !1
  }, r = s.screen.width, o = s.screen.height, l = n.match(/(Android);?[\s\/]+([\d.]+)?/);
  let c = n.match(/(iPad).*OS\s([\d_]+)/);
  const u = n.match(/(iPod)(.*OS\s([\d_]+))?/), d = !c && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = i === "Win32";
  let g = i === "MacIntel";
  const p = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  return !c && g && t.touch && p.indexOf(`${r}x${o}`) >= 0 && (c = n.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), g = !1), l && !h && (a.os = "android", a.android = !0), (c || d || u) && (a.os = "ios", a.ios = !0), a;
}
function getDevice(e = {}) {
  return deviceCached || (deviceCached = calcDevice(e)), deviceCached;
}
let browser;
function calcBrowser() {
  const e = getWindow();
  let t = !1;
  function s() {
    const i = e.navigator.userAgent.toLowerCase();
    return i.indexOf("safari") >= 0 && i.indexOf("chrome") < 0 && i.indexOf("android") < 0;
  }
  if (s()) {
    const i = String(e.navigator.userAgent);
    if (i.includes("Version/")) {
      const [n, a] = i.split("Version/")[1].split(" ")[0].split(".").map((r) => Number(r));
      t = n < 16 || n === 16 && a < 2;
    }
  }
  return {
    isSafari: t || s(),
    needPerspectiveFix: t,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
  };
}
function getBrowser() {
  return browser || (browser = calcBrowser()), browser;
}
function Resize({
  swiper: e,
  on: t,
  emit: s
}) {
  const i = getWindow();
  let n = null, a = null;
  const r = () => {
    !e || e.destroyed || !e.initialized || (s("beforeResize"), s("resize"));
  }, o = () => {
    !e || e.destroyed || !e.initialized || (n = new ResizeObserver((u) => {
      a = i.requestAnimationFrame(() => {
        const {
          width: d,
          height: h
        } = e;
        let g = d, p = h;
        u.forEach(({
          contentBoxSize: m,
          contentRect: v,
          target: f
        }) => {
          f && f !== e.el || (g = v ? v.width : (m[0] || m).inlineSize, p = v ? v.height : (m[0] || m).blockSize);
        }), (g !== d || p !== h) && r();
      });
    }), n.observe(e.el));
  }, l = () => {
    a && i.cancelAnimationFrame(a), n && n.unobserve && e.el && (n.unobserve(e.el), n = null);
  }, c = () => {
    !e || e.destroyed || !e.initialized || s("orientationchange");
  };
  t("init", () => {
    if (e.params.resizeObserver && typeof i.ResizeObserver < "u") {
      o();
      return;
    }
    i.addEventListener("resize", r), i.addEventListener("orientationchange", c);
  }), t("destroy", () => {
    l(), i.removeEventListener("resize", r), i.removeEventListener("orientationchange", c);
  });
}
function Observer({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  const n = [], a = getWindow(), r = (c, u = {}) => {
    const d = a.MutationObserver || a.WebkitMutationObserver, h = new d((g) => {
      if (g.length === 1) {
        i("observerUpdate", g[0]);
        return;
      }
      const p = function() {
        i("observerUpdate", g[0]);
      };
      a.requestAnimationFrame ? a.requestAnimationFrame(p) : a.setTimeout(p, 0);
    });
    h.observe(c, {
      attributes: typeof u.attributes > "u" ? !0 : u.attributes,
      childList: typeof u.childList > "u" ? !0 : u.childList,
      characterData: typeof u.characterData > "u" ? !0 : u.characterData
    }), n.push(h);
  }, o = () => {
    if (e.params.observer) {
      if (e.params.observeParents) {
        const c = elementParents(e.el);
        for (let u = 0; u < c.length; u += 1)
          r(c[u]);
      }
      r(e.el, {
        childList: e.params.observeSlideChildren
      }), r(e.wrapperEl, {
        attributes: !1
      });
    }
  }, l = () => {
    n.forEach((c) => {
      c.disconnect();
    }), n.splice(0, n.length);
  };
  t({
    observer: !1,
    observeParents: !1,
    observeSlideChildren: !1
  }), s("init", o), s("destroy", l);
}
const eventsEmitter = {
  on(e, t, s) {
    const i = this;
    if (!i.eventsListeners || i.destroyed || typeof t != "function")
      return i;
    const n = s ? "unshift" : "push";
    return e.split(" ").forEach((a) => {
      i.eventsListeners[a] || (i.eventsListeners[a] = []), i.eventsListeners[a][n](t);
    }), i;
  },
  once(e, t, s) {
    const i = this;
    if (!i.eventsListeners || i.destroyed || typeof t != "function")
      return i;
    function n(...a) {
      i.off(e, n), n.__emitterProxy && delete n.__emitterProxy, t.apply(i, a);
    }
    return n.__emitterProxy = t, i.on(e, n, s);
  },
  onAny(e, t) {
    const s = this;
    if (!s.eventsListeners || s.destroyed || typeof e != "function")
      return s;
    const i = t ? "unshift" : "push";
    return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[i](e), s;
  },
  offAny(e) {
    const t = this;
    if (!t.eventsListeners || t.destroyed || !t.eventsAnyListeners)
      return t;
    const s = t.eventsAnyListeners.indexOf(e);
    return s >= 0 && t.eventsAnyListeners.splice(s, 1), t;
  },
  off(e, t) {
    const s = this;
    return !s.eventsListeners || s.destroyed || !s.eventsListeners || e.split(" ").forEach((i) => {
      typeof t > "u" ? s.eventsListeners[i] = [] : s.eventsListeners[i] && s.eventsListeners[i].forEach((n, a) => {
        (n === t || n.__emitterProxy && n.__emitterProxy === t) && s.eventsListeners[i].splice(a, 1);
      });
    }), s;
  },
  emit(...e) {
    const t = this;
    if (!t.eventsListeners || t.destroyed || !t.eventsListeners)
      return t;
    let s, i, n;
    return typeof e[0] == "string" || Array.isArray(e[0]) ? (s = e[0], i = e.slice(1, e.length), n = t) : (s = e[0].events, i = e[0].data, n = e[0].context || t), i.unshift(n), (Array.isArray(s) ? s : s.split(" ")).forEach((r) => {
      t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((o) => {
        o.apply(n, [r, ...i]);
      }), t.eventsListeners && t.eventsListeners[r] && t.eventsListeners[r].forEach((o) => {
        o.apply(n, i);
      });
    }), t;
  }
};
function updateSize() {
  const e = this;
  let t, s;
  const i = e.el;
  typeof e.params.width < "u" && e.params.width !== null ? t = e.params.width : t = i.clientWidth, typeof e.params.height < "u" && e.params.height !== null ? s = e.params.height : s = i.clientHeight, !(t === 0 && e.isHorizontal() || s === 0 && e.isVertical()) && (t = t - parseInt(elementStyle(i, "padding-left") || 0, 10) - parseInt(elementStyle(i, "padding-right") || 0, 10), s = s - parseInt(elementStyle(i, "padding-top") || 0, 10) - parseInt(elementStyle(i, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
    width: t,
    height: s,
    size: e.isHorizontal() ? t : s
  }));
}
function updateSlides() {
  const e = this;
  function t(S) {
    return e.isHorizontal() ? S : {
      width: "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      marginRight: "marginBottom"
    }[S];
  }
  function s(S, x) {
    return parseFloat(S.getPropertyValue(t(x)) || 0);
  }
  const i = e.params, {
    wrapperEl: n,
    slidesEl: a,
    size: r,
    rtlTranslate: o,
    wrongRTL: l
  } = e, c = e.virtual && i.virtual.enabled, u = c ? e.virtual.slides.length : e.slides.length, d = elementChildren(a, `.${e.params.slideClass}, swiper-slide`), h = c ? e.virtual.slides.length : d.length;
  let g = [];
  const p = [], m = [];
  let v = i.slidesOffsetBefore;
  typeof v == "function" && (v = i.slidesOffsetBefore.call(e));
  let f = i.slidesOffsetAfter;
  typeof f == "function" && (f = i.slidesOffsetAfter.call(e));
  const b = e.snapGrid.length, E = e.slidesGrid.length;
  let A = i.spaceBetween, C = -v, w = 0, M = 0;
  if (typeof r > "u")
    return;
  typeof A == "string" && A.indexOf("%") >= 0 && (A = parseFloat(A.replace("%", "")) / 100 * r), e.virtualSize = -A, d.forEach((S) => {
    o ? S.style.marginLeft = "" : S.style.marginRight = "", S.style.marginBottom = "", S.style.marginTop = "";
  }), i.centeredSlides && i.cssMode && (setCSSProperty(n, "--swiper-centered-offset-before", ""), setCSSProperty(n, "--swiper-centered-offset-after", ""));
  const k = i.grid && i.grid.rows > 1 && e.grid;
  k && e.grid.initSlides(h);
  let O;
  const z = i.slidesPerView === "auto" && i.breakpoints && Object.keys(i.breakpoints).filter((S) => typeof i.breakpoints[S].slidesPerView < "u").length > 0;
  for (let S = 0; S < h; S += 1) {
    O = 0;
    let x;
    if (d[S] && (x = d[S]), k && e.grid.updateSlide(S, x, h, t), !(d[S] && elementStyle(x, "display") === "none")) {
      if (i.slidesPerView === "auto") {
        z && (d[S].style[t("width")] = "");
        const y = getComputedStyle(x), T = x.style.transform, $ = x.style.webkitTransform;
        if (T && (x.style.transform = "none"), $ && (x.style.webkitTransform = "none"), i.roundLengths)
          O = e.isHorizontal() ? elementOuterSize(x, "width", !0) : elementOuterSize(x, "height", !0);
        else {
          const _ = s(y, "width"), L = s(y, "padding-left"), P = s(y, "padding-right"), D = s(y, "margin-left"), R = s(y, "margin-right"), N = y.getPropertyValue("box-sizing");
          if (N && N === "border-box")
            O = _ + D + R;
          else {
            const {
              clientWidth: I,
              offsetWidth: B
            } = x;
            O = _ + L + P + D + R + (B - I);
          }
        }
        T && (x.style.transform = T), $ && (x.style.webkitTransform = $), i.roundLengths && (O = Math.floor(O));
      } else
        O = (r - (i.slidesPerView - 1) * A) / i.slidesPerView, i.roundLengths && (O = Math.floor(O)), d[S] && (d[S].style[t("width")] = `${O}px`);
      d[S] && (d[S].swiperSlideSize = O), m.push(O), i.centeredSlides ? (C = C + O / 2 + w / 2 + A, w === 0 && S !== 0 && (C = C - r / 2 - A), S === 0 && (C = C - r / 2 - A), Math.abs(C) < 1 / 1e3 && (C = 0), i.roundLengths && (C = Math.floor(C)), M % i.slidesPerGroup === 0 && g.push(C), p.push(C)) : (i.roundLengths && (C = Math.floor(C)), (M - Math.min(e.params.slidesPerGroupSkip, M)) % e.params.slidesPerGroup === 0 && g.push(C), p.push(C), C = C + O + A), e.virtualSize += O + A, w = O, M += 1;
    }
  }
  if (e.virtualSize = Math.max(e.virtualSize, r) + f, o && l && (i.effect === "slide" || i.effect === "coverflow") && (n.style.width = `${e.virtualSize + i.spaceBetween}px`), i.setWrapperSize && (n.style[t("width")] = `${e.virtualSize + i.spaceBetween}px`), k && e.grid.updateWrapperSize(O, g, t), !i.centeredSlides) {
    const S = [];
    for (let x = 0; x < g.length; x += 1) {
      let y = g[x];
      i.roundLengths && (y = Math.floor(y)), g[x] <= e.virtualSize - r && S.push(y);
    }
    g = S, Math.floor(e.virtualSize - r) - Math.floor(g[g.length - 1]) > 1 && g.push(e.virtualSize - r);
  }
  if (c && i.loop) {
    const S = m[0] + A;
    if (i.slidesPerGroup > 1) {
      const x = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup), y = S * i.slidesPerGroup;
      for (let T = 0; T < x; T += 1)
        g.push(g[g.length - 1] + y);
    }
    for (let x = 0; x < e.virtual.slidesBefore + e.virtual.slidesAfter; x += 1)
      i.slidesPerGroup === 1 && g.push(g[g.length - 1] + S), p.push(p[p.length - 1] + S), e.virtualSize += S;
  }
  if (g.length === 0 && (g = [0]), i.spaceBetween !== 0) {
    const S = e.isHorizontal() && o ? "marginLeft" : t("marginRight");
    d.filter((x, y) => !i.cssMode || i.loop ? !0 : y !== d.length - 1).forEach((x) => {
      x.style[S] = `${A}px`;
    });
  }
  if (i.centeredSlides && i.centeredSlidesBounds) {
    let S = 0;
    m.forEach((y) => {
      S += y + (i.spaceBetween ? i.spaceBetween : 0);
    }), S -= i.spaceBetween;
    const x = S - r;
    g = g.map((y) => y < 0 ? -v : y > x ? x + f : y);
  }
  if (i.centerInsufficientSlides) {
    let S = 0;
    if (m.forEach((x) => {
      S += x + (i.spaceBetween ? i.spaceBetween : 0);
    }), S -= i.spaceBetween, S < r) {
      const x = (r - S) / 2;
      g.forEach((y, T) => {
        g[T] = y - x;
      }), p.forEach((y, T) => {
        p[T] = y + x;
      });
    }
  }
  if (Object.assign(e, {
    slides: d,
    snapGrid: g,
    slidesGrid: p,
    slidesSizesGrid: m
  }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
    setCSSProperty(n, "--swiper-centered-offset-before", `${-g[0]}px`), setCSSProperty(n, "--swiper-centered-offset-after", `${e.size / 2 - m[m.length - 1] / 2}px`);
    const S = -e.snapGrid[0], x = -e.slidesGrid[0];
    e.snapGrid = e.snapGrid.map((y) => y + S), e.slidesGrid = e.slidesGrid.map((y) => y + x);
  }
  if (h !== u && e.emit("slidesLengthChange"), g.length !== b && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== E && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), !c && !i.cssMode && (i.effect === "slide" || i.effect === "fade")) {
    const S = `${i.containerModifierClass}backface-hidden`, x = e.el.classList.contains(S);
    h <= i.maxBackfaceHiddenSlides ? x || e.el.classList.add(S) : x && e.el.classList.remove(S);
  }
}
function updateAutoHeight(e) {
  const t = this, s = [], i = t.virtual && t.params.virtual.enabled;
  let n = 0, a;
  typeof e == "number" ? t.setTransition(e) : e === !0 && t.setTransition(t.params.speed);
  const r = (o) => i ? t.slides.filter((l) => parseInt(l.getAttribute("data-swiper-slide-index"), 10) === o)[0] : t.slides[o];
  if (t.params.slidesPerView !== "auto" && t.params.slidesPerView > 1)
    if (t.params.centeredSlides)
      (t.visibleSlides || []).forEach((o) => {
        s.push(o);
      });
    else
      for (a = 0; a < Math.ceil(t.params.slidesPerView); a += 1) {
        const o = t.activeIndex + a;
        if (o > t.slides.length && !i)
          break;
        s.push(r(o));
      }
  else
    s.push(r(t.activeIndex));
  for (a = 0; a < s.length; a += 1)
    if (typeof s[a] < "u") {
      const o = s[a].offsetHeight;
      n = o > n ? o : n;
    }
  (n || n === 0) && (t.wrapperEl.style.height = `${n}px`);
}
function updateSlidesOffset() {
  const e = this, t = e.slides, s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
  for (let i = 0; i < t.length; i += 1)
    t[i].swiperSlideOffset = (e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop) - s;
}
function updateSlidesProgress(e = this && this.translate || 0) {
  const t = this, s = t.params, {
    slides: i,
    rtlTranslate: n,
    snapGrid: a
  } = t;
  if (i.length === 0)
    return;
  typeof i[0].swiperSlideOffset > "u" && t.updateSlidesOffset();
  let r = -e;
  n && (r = e), i.forEach((o) => {
    o.classList.remove(s.slideVisibleClass);
  }), t.visibleSlidesIndexes = [], t.visibleSlides = [];
  for (let o = 0; o < i.length; o += 1) {
    const l = i[o];
    let c = l.swiperSlideOffset;
    s.cssMode && s.centeredSlides && (c -= i[0].swiperSlideOffset);
    const u = (r + (s.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + s.spaceBetween), d = (r - a[0] + (s.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + s.spaceBetween), h = -(r - c), g = h + t.slidesSizesGrid[o];
    (h >= 0 && h < t.size - 1 || g > 1 && g <= t.size || h <= 0 && g >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(o), i[o].classList.add(s.slideVisibleClass)), l.progress = n ? -u : u, l.originalProgress = n ? -d : d;
  }
}
function updateProgress(e) {
  const t = this;
  if (typeof e > "u") {
    const u = t.rtlTranslate ? -1 : 1;
    e = t && t.translate && t.translate * u || 0;
  }
  const s = t.params, i = t.maxTranslate() - t.minTranslate();
  let {
    progress: n,
    isBeginning: a,
    isEnd: r,
    progressLoop: o
  } = t;
  const l = a, c = r;
  if (i === 0)
    n = 0, a = !0, r = !0;
  else {
    n = (e - t.minTranslate()) / i;
    const u = Math.abs(e - t.minTranslate()) < 1, d = Math.abs(e - t.maxTranslate()) < 1;
    a = u || n <= 0, r = d || n >= 1, u && (n = 0), d && (n = 1);
  }
  if (s.loop) {
    const u = elementIndex(t.slides.filter((v) => v.getAttribute("data-swiper-slide-index") === "0")[0]), d = elementIndex(t.slides.filter((v) => v.getAttribute("data-swiper-slide-index") * 1 === t.slides.length - 1)[0]), h = t.slidesGrid[u], g = t.slidesGrid[d], p = t.slidesGrid[t.slidesGrid.length - 1], m = Math.abs(e);
    m >= h ? o = (m - h) / p : o = (m + p - g) / p, o > 1 && (o -= 1);
  }
  Object.assign(t, {
    progress: n,
    progressLoop: o,
    isBeginning: a,
    isEnd: r
  }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), a && !l && t.emit("reachBeginning toEdge"), r && !c && t.emit("reachEnd toEdge"), (l && !a || c && !r) && t.emit("fromEdge"), t.emit("progress", n);
}
function updateSlidesClasses() {
  const e = this, {
    slides: t,
    params: s,
    slidesEl: i,
    activeIndex: n
  } = e, a = e.virtual && s.virtual.enabled, r = (l) => elementChildren(i, `.${s.slideClass}${l}, swiper-slide${l}`)[0];
  t.forEach((l) => {
    l.classList.remove(s.slideActiveClass, s.slideNextClass, s.slidePrevClass);
  });
  let o;
  if (a)
    if (s.loop) {
      let l = n - e.virtual.slidesBefore;
      l < 0 && (l = e.virtual.slides.length + l), l >= e.virtual.slides.length && (l -= e.virtual.slides.length), o = r(`[data-swiper-slide-index="${l}"]`);
    } else
      o = r(`[data-swiper-slide-index="${n}"]`);
  else
    o = t[n];
  if (o) {
    o.classList.add(s.slideActiveClass);
    let l = elementNextAll(o, `.${s.slideClass}, swiper-slide`)[0];
    s.loop && !l && (l = t[0]), l && l.classList.add(s.slideNextClass);
    let c = elementPrevAll(o, `.${s.slideClass}, swiper-slide`)[0];
    s.loop && !c === 0 && (c = t[t.length - 1]), c && c.classList.add(s.slidePrevClass);
  }
  e.emitSlidesClasses();
}
function getActiveIndexByTranslate(e) {
  const {
    slidesGrid: t,
    params: s
  } = e, i = e.rtlTranslate ? e.translate : -e.translate;
  let n;
  for (let a = 0; a < t.length; a += 1)
    typeof t[a + 1] < "u" ? i >= t[a] && i < t[a + 1] - (t[a + 1] - t[a]) / 2 ? n = a : i >= t[a] && i < t[a + 1] && (n = a + 1) : i >= t[a] && (n = a);
  return s.normalizeSlideIndex && (n < 0 || typeof n > "u") && (n = 0), n;
}
function updateActiveIndex(e) {
  const t = this, s = t.rtlTranslate ? t.translate : -t.translate, {
    snapGrid: i,
    params: n,
    activeIndex: a,
    realIndex: r,
    snapIndex: o
  } = t;
  let l = e, c;
  const u = (h) => {
    let g = h - t.virtual.slidesBefore;
    return g < 0 && (g = t.virtual.slides.length + g), g >= t.virtual.slides.length && (g -= t.virtual.slides.length), g;
  };
  if (typeof l > "u" && (l = getActiveIndexByTranslate(t)), i.indexOf(s) >= 0)
    c = i.indexOf(s);
  else {
    const h = Math.min(n.slidesPerGroupSkip, l);
    c = h + Math.floor((l - h) / n.slidesPerGroup);
  }
  if (c >= i.length && (c = i.length - 1), l === a) {
    c !== o && (t.snapIndex = c, t.emit("snapIndexChange")), t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = u(l));
    return;
  }
  let d;
  t.virtual && n.virtual.enabled && n.loop ? d = u(l) : t.slides[l] ? d = parseInt(t.slides[l].getAttribute("data-swiper-slide-index") || l, 10) : d = l, Object.assign(t, {
    snapIndex: c,
    realIndex: d,
    previousIndex: a,
    activeIndex: l
  }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), r !== d && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange");
}
function updateClickedSlide(e) {
  const t = this, s = t.params, i = e.closest(`.${s.slideClass}, swiper-slide`);
  let n = !1, a;
  if (i) {
    for (let r = 0; r < t.slides.length; r += 1)
      if (t.slides[r] === i) {
        n = !0, a = r;
        break;
      }
  }
  if (i && n)
    t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = a;
  else {
    t.clickedSlide = void 0, t.clickedIndex = void 0;
    return;
  }
  s.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide();
}
const update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(e = this.isHorizontal() ? "x" : "y") {
  const t = this, {
    params: s,
    rtlTranslate: i,
    translate: n,
    wrapperEl: a
  } = t;
  if (s.virtualTranslate)
    return i ? -n : n;
  if (s.cssMode)
    return n;
  let r = getTranslate(a, e);
  return i && (r = -r), r || 0;
}
function setTranslate(e, t) {
  const s = this, {
    rtlTranslate: i,
    params: n,
    wrapperEl: a,
    progress: r
  } = s;
  let o = 0, l = 0;
  const c = 0;
  s.isHorizontal() ? o = i ? -e : e : l = e, n.roundLengths && (o = Math.floor(o), l = Math.floor(l)), n.cssMode ? a[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -o : -l : n.virtualTranslate || (a.style.transform = `translate3d(${o}px, ${l}px, ${c}px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? o : l;
  let u;
  const d = s.maxTranslate() - s.minTranslate();
  d === 0 ? u = 0 : u = (e - s.minTranslate()) / d, u !== r && s.updateProgress(e), s.emit("setTranslate", s.translate, t);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(e = 0, t = this.params.speed, s = !0, i = !0, n) {
  const a = this, {
    params: r,
    wrapperEl: o
  } = a;
  if (a.animating && r.preventInteractionOnTransition)
    return !1;
  const l = a.minTranslate(), c = a.maxTranslate();
  let u;
  if (i && e > l ? u = l : i && e < c ? u = c : u = e, a.updateProgress(u), r.cssMode) {
    const d = a.isHorizontal();
    if (t === 0)
      o[d ? "scrollLeft" : "scrollTop"] = -u;
    else {
      if (!a.support.smoothScroll)
        return animateCSSModeScroll({
          swiper: a,
          targetPosition: -u,
          side: d ? "left" : "top"
        }), !0;
      o.scrollTo({
        [d ? "left" : "top"]: -u,
        behavior: "smooth"
      });
    }
    return !0;
  }
  return t === 0 ? (a.setTransition(0), a.setTranslate(u), s && (a.emit("beforeTransitionStart", t, n), a.emit("transitionEnd"))) : (a.setTransition(t), a.setTranslate(u), s && (a.emit("beforeTransitionStart", t, n), a.emit("transitionStart")), a.animating || (a.animating = !0, a.onTranslateToWrapperTransitionEnd || (a.onTranslateToWrapperTransitionEnd = function(h) {
    !a || a.destroyed || h.target === this && (a.wrapperEl.removeEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.onTranslateToWrapperTransitionEnd = null, delete a.onTranslateToWrapperTransitionEnd, s && a.emit("transitionEnd"));
  }), a.wrapperEl.addEventListener("transitionend", a.onTranslateToWrapperTransitionEnd))), !0;
}
const translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(e, t) {
  const s = this;
  s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`), s.emit("setTransition", e, t);
}
function transitionEmit({
  swiper: e,
  runCallbacks: t,
  direction: s,
  step: i
}) {
  const {
    activeIndex: n,
    previousIndex: a
  } = e;
  let r = s;
  if (r || (n > a ? r = "next" : n < a ? r = "prev" : r = "reset"), e.emit(`transition${i}`), t && n !== a) {
    if (r === "reset") {
      e.emit(`slideResetTransition${i}`);
      return;
    }
    e.emit(`slideChangeTransition${i}`), r === "next" ? e.emit(`slideNextTransition${i}`) : e.emit(`slidePrevTransition${i}`);
  }
}
function transitionStart(e = !0, t) {
  const s = this, {
    params: i
  } = s;
  i.cssMode || (i.autoHeight && s.updateAutoHeight(), transitionEmit({
    swiper: s,
    runCallbacks: e,
    direction: t,
    step: "Start"
  }));
}
function transitionEnd(e = !0, t) {
  const s = this, {
    params: i
  } = s;
  s.animating = !1, !i.cssMode && (s.setTransition(0), transitionEmit({
    swiper: s,
    runCallbacks: e,
    direction: t,
    step: "End"
  }));
}
const transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(e = 0, t = this.params.speed, s = !0, i, n) {
  typeof e == "string" && (e = parseInt(e, 10));
  const a = this;
  let r = e;
  r < 0 && (r = 0);
  const {
    params: o,
    snapGrid: l,
    slidesGrid: c,
    previousIndex: u,
    activeIndex: d,
    rtlTranslate: h,
    wrapperEl: g,
    enabled: p
  } = a;
  if (a.animating && o.preventInteractionOnTransition || !p && !i && !n)
    return !1;
  const m = Math.min(a.params.slidesPerGroupSkip, r);
  let v = m + Math.floor((r - m) / a.params.slidesPerGroup);
  v >= l.length && (v = l.length - 1);
  const f = -l[v];
  if (o.normalizeSlideIndex)
    for (let E = 0; E < c.length; E += 1) {
      const A = -Math.floor(f * 100), C = Math.floor(c[E] * 100), w = Math.floor(c[E + 1] * 100);
      typeof c[E + 1] < "u" ? A >= C && A < w - (w - C) / 2 ? r = E : A >= C && A < w && (r = E + 1) : A >= C && (r = E);
    }
  if (a.initialized && r !== d && (!a.allowSlideNext && f < a.translate && f < a.minTranslate() || !a.allowSlidePrev && f > a.translate && f > a.maxTranslate() && (d || 0) !== r))
    return !1;
  r !== (u || 0) && s && a.emit("beforeSlideChangeStart"), a.updateProgress(f);
  let b;
  if (r > d ? b = "next" : r < d ? b = "prev" : b = "reset", h && -f === a.translate || !h && f === a.translate)
    return a.updateActiveIndex(r), o.autoHeight && a.updateAutoHeight(), a.updateSlidesClasses(), o.effect !== "slide" && a.setTranslate(f), b !== "reset" && (a.transitionStart(s, b), a.transitionEnd(s, b)), !1;
  if (o.cssMode) {
    const E = a.isHorizontal(), A = h ? f : -f;
    if (t === 0) {
      const C = a.virtual && a.params.virtual.enabled;
      C && (a.wrapperEl.style.scrollSnapType = "none", a._immediateVirtual = !0), C && !a._cssModeVirtualInitialSet && a.params.initialSlide > 0 ? (a._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
        g[E ? "scrollLeft" : "scrollTop"] = A;
      })) : g[E ? "scrollLeft" : "scrollTop"] = A, C && requestAnimationFrame(() => {
        a.wrapperEl.style.scrollSnapType = "", a._immediateVirtual = !1;
      });
    } else {
      if (!a.support.smoothScroll)
        return animateCSSModeScroll({
          swiper: a,
          targetPosition: A,
          side: E ? "left" : "top"
        }), !0;
      g.scrollTo({
        [E ? "left" : "top"]: A,
        behavior: "smooth"
      });
    }
    return !0;
  }
  return a.setTransition(t), a.setTranslate(f), a.updateActiveIndex(r), a.updateSlidesClasses(), a.emit("beforeTransitionStart", t, i), a.transitionStart(s, b), t === 0 ? a.transitionEnd(s, b) : a.animating || (a.animating = !0, a.onSlideToWrapperTransitionEnd || (a.onSlideToWrapperTransitionEnd = function(A) {
    !a || a.destroyed || A.target === this && (a.wrapperEl.removeEventListener("transitionend", a.onSlideToWrapperTransitionEnd), a.onSlideToWrapperTransitionEnd = null, delete a.onSlideToWrapperTransitionEnd, a.transitionEnd(s, b));
  }), a.wrapperEl.addEventListener("transitionend", a.onSlideToWrapperTransitionEnd)), !0;
}
function slideToLoop(e = 0, t = this.params.speed, s = !0, i) {
  typeof e == "string" && (e = parseInt(e, 10));
  const n = this;
  let a = e;
  return n.params.loop && (n.virtual && n.params.virtual.enabled ? a = a + n.virtual.slidesBefore : a = elementIndex(n.slides.filter((r) => r.getAttribute("data-swiper-slide-index") * 1 === a)[0])), n.slideTo(a, t, s, i);
}
function slideNext(e = this.params.speed, t = !0, s) {
  const i = this, {
    enabled: n,
    params: a,
    animating: r
  } = i;
  if (!n)
    return i;
  let o = a.slidesPerGroup;
  a.slidesPerView === "auto" && a.slidesPerGroup === 1 && a.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1));
  const l = i.activeIndex < a.slidesPerGroupSkip ? 1 : o, c = i.virtual && a.virtual.enabled;
  if (a.loop) {
    if (r && !c && a.loopPreventsSliding)
      return !1;
    i.loopFix({
      direction: "next"
    }), i._clientLeft = i.wrapperEl.clientLeft;
  }
  return a.rewind && i.isEnd ? i.slideTo(0, e, t, s) : i.slideTo(i.activeIndex + l, e, t, s);
}
function slidePrev(e = this.params.speed, t = !0, s) {
  const i = this, {
    params: n,
    snapGrid: a,
    slidesGrid: r,
    rtlTranslate: o,
    enabled: l,
    animating: c
  } = i;
  if (!l)
    return i;
  const u = i.virtual && n.virtual.enabled;
  if (n.loop) {
    if (c && !u && n.loopPreventsSliding)
      return !1;
    i.loopFix({
      direction: "prev"
    }), i._clientLeft = i.wrapperEl.clientLeft;
  }
  const d = o ? i.translate : -i.translate;
  function h(f) {
    return f < 0 ? -Math.floor(Math.abs(f)) : Math.floor(f);
  }
  const g = h(d), p = a.map((f) => h(f));
  let m = a[p.indexOf(g) - 1];
  if (typeof m > "u" && n.cssMode) {
    let f;
    a.forEach((b, E) => {
      g >= b && (f = E);
    }), typeof f < "u" && (m = a[f > 0 ? f - 1 : f]);
  }
  let v = 0;
  if (typeof m < "u" && (v = r.indexOf(m), v < 0 && (v = i.activeIndex - 1), n.slidesPerView === "auto" && n.slidesPerGroup === 1 && n.slidesPerGroupAuto && (v = v - i.slidesPerViewDynamic("previous", !0) + 1, v = Math.max(v, 0))), n.rewind && i.isBeginning) {
    const f = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1;
    return i.slideTo(f, e, t, s);
  }
  return i.slideTo(v, e, t, s);
}
function slideReset(e = this.params.speed, t = !0, s) {
  const i = this;
  return i.slideTo(i.activeIndex, e, t, s);
}
function slideToClosest(e = this.params.speed, t = !0, s, i = 0.5) {
  const n = this;
  let a = n.activeIndex;
  const r = Math.min(n.params.slidesPerGroupSkip, a), o = r + Math.floor((a - r) / n.params.slidesPerGroup), l = n.rtlTranslate ? n.translate : -n.translate;
  if (l >= n.snapGrid[o]) {
    const c = n.snapGrid[o], u = n.snapGrid[o + 1];
    l - c > (u - c) * i && (a += n.params.slidesPerGroup);
  } else {
    const c = n.snapGrid[o - 1], u = n.snapGrid[o];
    l - c <= (u - c) * i && (a -= n.params.slidesPerGroup);
  }
  return a = Math.max(a, 0), a = Math.min(a, n.slidesGrid.length - 1), n.slideTo(a, e, t, s);
}
function slideToClickedSlide() {
  const e = this, {
    params: t,
    slidesEl: s
  } = e, i = t.slidesPerView === "auto" ? e.slidesPerViewDynamic() : t.slidesPerView;
  let n = e.clickedIndex, a;
  const r = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
  if (t.loop) {
    if (e.animating)
      return;
    a = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? n < e.loopedSlides - i / 2 || n > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), n = elementIndex(elementChildren(s, `${r}[data-swiper-slide-index="${a}"]`)[0]), nextTick(() => {
      e.slideTo(n);
    })) : e.slideTo(n) : n > e.slides.length - i ? (e.loopFix(), n = elementIndex(elementChildren(s, `${r}[data-swiper-slide-index="${a}"]`)[0]), nextTick(() => {
      e.slideTo(n);
    })) : e.slideTo(n);
  } else
    e.slideTo(n);
}
const slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate(e) {
  const t = this, {
    params: s,
    slidesEl: i
  } = t;
  if (!s.loop || t.virtual && t.params.virtual.enabled)
    return;
  elementChildren(i, `.${s.slideClass}, swiper-slide`).forEach((a, r) => {
    a.setAttribute("data-swiper-slide-index", r);
  }), t.loopFix({
    slideRealIndex: e,
    direction: s.centeredSlides ? void 0 : "next"
  });
}
function loopFix({
  slideRealIndex: e,
  slideTo: t = !0,
  direction: s,
  setTranslate: i,
  activeSlideIndex: n,
  byController: a,
  byMousewheel: r
} = {}) {
  const o = this;
  if (!o.params.loop)
    return;
  o.emit("beforeLoopFix");
  const {
    slides: l,
    allowSlidePrev: c,
    allowSlideNext: u,
    slidesEl: d,
    params: h
  } = o;
  if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && h.virtual.enabled) {
    t && (!h.centeredSlides && o.snapIndex === 0 ? o.slideTo(o.virtual.slides.length, 0, !1, !0) : h.centeredSlides && o.snapIndex < h.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = u, o.emit("loopFix");
    return;
  }
  const g = h.slidesPerView === "auto" ? o.slidesPerViewDynamic() : Math.ceil(parseFloat(h.slidesPerView, 10));
  let p = h.loopedSlides || g;
  p % h.slidesPerGroup !== 0 && (p += h.slidesPerGroup - p % h.slidesPerGroup), o.loopedSlides = p;
  const m = [], v = [];
  let f = o.activeIndex;
  typeof n > "u" ? n = elementIndex(o.slides.filter((w) => w.classList.contains("swiper-slide-active"))[0]) : f = n;
  const b = s === "next" || !s, E = s === "prev" || !s;
  let A = 0, C = 0;
  if (n < p) {
    A = p - n;
    for (let w = 0; w < p - n; w += 1) {
      const M = w - Math.floor(w / l.length) * l.length;
      m.push(l.length - M - 1);
    }
  } else if (n > o.slides.length - p * 2) {
    C = n - (o.slides.length - p * 2);
    for (let w = 0; w < C; w += 1) {
      const M = w - Math.floor(w / l.length) * l.length;
      v.push(M);
    }
  }
  if (E && m.forEach((w) => {
    d.prepend(o.slides[w]);
  }), b && v.forEach((w) => {
    d.append(o.slides[w]);
  }), o.recalcSlides(), h.watchSlidesProgress && o.updateSlidesOffset(), t) {
    if (m.length > 0 && E)
      if (typeof e > "u") {
        const w = o.slidesGrid[f], k = o.slidesGrid[f + A] - w;
        r ? o.setTranslate(o.translate - k) : (o.slideTo(f + A, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += k));
      } else
        i && o.slideToLoop(e, 0, !1, !0);
    else if (v.length > 0 && b)
      if (typeof e > "u") {
        const w = o.slidesGrid[f], k = o.slidesGrid[f - C] - w;
        r ? o.setTranslate(o.translate - k) : (o.slideTo(f - C, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += k));
      } else
        o.slideToLoop(e, 0, !1, !0);
  }
  if (o.allowSlidePrev = c, o.allowSlideNext = u, o.controller && o.controller.control && !a) {
    const w = {
      slideRealIndex: e,
      slideTo: !1,
      direction: s,
      setTranslate: i,
      activeSlideIndex: n,
      byController: !0
    };
    Array.isArray(o.controller.control) ? o.controller.control.forEach((M) => {
      M.params.loop && M.loopFix(w);
    }) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix(w);
  }
  o.emit("loopFix");
}
function loopDestroy() {
  const e = this, {
    slides: t,
    params: s,
    slidesEl: i
  } = e;
  if (!s.loop || e.virtual && e.params.virtual.enabled)
    return;
  e.recalcSlides();
  const n = [];
  t.forEach((a) => {
    const r = typeof a.swiperSlideIndex > "u" ? a.getAttribute("data-swiper-slide-index") * 1 : a.swiperSlideIndex;
    n[r] = a;
  }), t.forEach((a) => {
    a.removeAttribute("data-swiper-slide-index");
  }), n.forEach((a) => {
    i.append(a);
  }), e.recalcSlides(), e.slideTo(e.realIndex, 0);
}
const loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(e) {
  const t = this;
  if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
    return;
  const s = t.params.touchEventsTarget === "container" ? t.el : t.wrapperEl;
  s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab";
}
function unsetGrabCursor() {
  const e = this;
  e.params.watchOverflow && e.isLocked || e.params.cssMode || (e[e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "");
}
const grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(e, t = this) {
  function s(i) {
    if (!i || i === getDocument() || i === getWindow())
      return null;
    i.assignedSlot && (i = i.assignedSlot);
    const n = i.closest(e);
    return !n && !i.getRootNode ? null : n || s(i.getRootNode().host);
  }
  return s(t);
}
function onTouchStart(e) {
  const t = this, s = getDocument(), i = getWindow(), n = t.touchEventsData;
  n.evCache.push(e);
  const {
    params: a,
    touches: r,
    enabled: o
  } = t;
  if (!o || !a.simulateTouch && e.pointerType === "mouse" || t.animating && a.preventInteractionOnTransition)
    return;
  !t.animating && a.cssMode && a.loop && t.loopFix();
  let l = e;
  l.originalEvent && (l = l.originalEvent);
  let c = l.target;
  if (a.touchEventsTarget === "wrapper" && !t.wrapperEl.contains(c) || "which" in l && l.which === 3 || "button" in l && l.button > 0 || n.isTouched && n.isMoved)
    return;
  const u = !!a.noSwipingClass && a.noSwipingClass !== "", d = e.composedPath ? e.composedPath() : e.path;
  u && l.target && l.target.shadowRoot && d && (c = d[0]);
  const h = a.noSwipingSelector ? a.noSwipingSelector : `.${a.noSwipingClass}`, g = !!(l.target && l.target.shadowRoot);
  if (a.noSwiping && (g ? closestElement(h, c) : c.closest(h))) {
    t.allowClick = !0;
    return;
  }
  if (a.swipeHandler && !c.closest(a.swipeHandler))
    return;
  r.currentX = l.pageX, r.currentY = l.pageY;
  const p = r.currentX, m = r.currentY, v = a.edgeSwipeDetection || a.iOSEdgeSwipeDetection, f = a.edgeSwipeThreshold || a.iOSEdgeSwipeThreshold;
  if (v && (p <= f || p >= i.innerWidth - f))
    if (v === "prevent")
      e.preventDefault();
    else
      return;
  Object.assign(n, {
    isTouched: !0,
    isMoved: !1,
    allowTouchCallbacks: !0,
    isScrolling: void 0,
    startMoving: void 0
  }), r.startX = p, r.startY = m, n.touchStartTime = now(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (n.allowThresholdMove = !1);
  let b = !0;
  c.matches(n.focusableElements) && (b = !1, c.nodeName === "SELECT" && (n.isTouched = !1)), s.activeElement && s.activeElement.matches(n.focusableElements) && s.activeElement !== c && s.activeElement.blur();
  const E = b && t.allowTouchMove && a.touchStartPreventDefault;
  (a.touchStartForcePreventDefault || E) && !c.isContentEditable && l.preventDefault(), t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", l);
}
function onTouchMove(e) {
  const t = getDocument(), s = this, i = s.touchEventsData, {
    params: n,
    touches: a,
    rtlTranslate: r,
    enabled: o
  } = s;
  if (!o || !n.simulateTouch && e.pointerType === "mouse")
    return;
  let l = e;
  if (l.originalEvent && (l = l.originalEvent), !i.isTouched) {
    i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", l);
    return;
  }
  const c = i.evCache.findIndex((w) => w.pointerId === l.pointerId);
  c >= 0 && (i.evCache[c] = l);
  const u = i.evCache.length > 1 ? i.evCache[0] : l, d = u.pageX, h = u.pageY;
  if (l.preventedByNestedSwiper) {
    a.startX = d, a.startY = h;
    return;
  }
  if (!s.allowTouchMove) {
    l.target.matches(i.focusableElements) || (s.allowClick = !1), i.isTouched && (Object.assign(a, {
      startX: d,
      startY: h,
      prevX: s.touches.currentX,
      prevY: s.touches.currentY,
      currentX: d,
      currentY: h
    }), i.touchStartTime = now());
    return;
  }
  if (n.touchReleaseOnEdges && !n.loop) {
    if (s.isVertical()) {
      if (h < a.startY && s.translate <= s.maxTranslate() || h > a.startY && s.translate >= s.minTranslate()) {
        i.isTouched = !1, i.isMoved = !1;
        return;
      }
    } else if (d < a.startX && s.translate <= s.maxTranslate() || d > a.startX && s.translate >= s.minTranslate())
      return;
  }
  if (t.activeElement && l.target === t.activeElement && l.target.matches(i.focusableElements)) {
    i.isMoved = !0, s.allowClick = !1;
    return;
  }
  if (i.allowTouchCallbacks && s.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1)
    return;
  a.currentX = d, a.currentY = h;
  const g = a.currentX - a.startX, p = a.currentY - a.startY;
  if (s.params.threshold && Math.sqrt(g ** 2 + p ** 2) < s.params.threshold)
    return;
  if (typeof i.isScrolling > "u") {
    let w;
    s.isHorizontal() && a.currentY === a.startY || s.isVertical() && a.currentX === a.startX ? i.isScrolling = !1 : g * g + p * p >= 25 && (w = Math.atan2(Math.abs(p), Math.abs(g)) * 180 / Math.PI, i.isScrolling = s.isHorizontal() ? w > n.touchAngle : 90 - w > n.touchAngle);
  }
  if (i.isScrolling && s.emit("touchMoveOpposite", l), typeof i.startMoving > "u" && (a.currentX !== a.startX || a.currentY !== a.startY) && (i.startMoving = !0), i.isScrolling || s.zoom && s.params.zoom && s.params.zoom.enabled && i.evCache.length > 1) {
    i.isTouched = !1;
    return;
  }
  if (!i.startMoving)
    return;
  s.allowClick = !1, !n.cssMode && l.cancelable && l.preventDefault(), n.touchMoveStopPropagation && !n.nested && l.stopPropagation();
  let m = s.isHorizontal() ? g : p, v = s.isHorizontal() ? a.currentX - a.previousX : a.currentY - a.previousY;
  n.oneWayMovement && (m = Math.abs(m) * (r ? 1 : -1), v = Math.abs(v) * (r ? 1 : -1)), a.diff = m, m *= n.touchRatio, r && (m = -m, v = -v);
  const f = s.touchesDirection;
  s.swipeDirection = m > 0 ? "prev" : "next", s.touchesDirection = v > 0 ? "prev" : "next";
  const b = s.params.loop && !n.cssMode;
  if (!i.isMoved) {
    if (b && s.loopFix({
      direction: s.swipeDirection
    }), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) {
      const w = new window.CustomEvent("transitionend", {
        bubbles: !0,
        cancelable: !0
      });
      s.wrapperEl.dispatchEvent(w);
    }
    i.allowMomentumBounce = !1, n.grabCursor && (s.allowSlideNext === !0 || s.allowSlidePrev === !0) && s.setGrabCursor(!0), s.emit("sliderFirstMove", l);
  }
  let E;
  i.isMoved && f !== s.touchesDirection && b && Math.abs(m) >= 1 && (s.loopFix({
    direction: s.swipeDirection,
    setTranslate: !0
  }), E = !0), s.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = m + i.startTranslate;
  let A = !0, C = n.resistanceRatio;
  if (n.touchReleaseOnEdges && (C = 0), m > 0 ? (b && !E && i.currentTranslate > (n.centeredSlides ? s.minTranslate() - s.size / 2 : s.minTranslate()) && s.loopFix({
    direction: "prev",
    setTranslate: !0,
    activeSlideIndex: 0
  }), i.currentTranslate > s.minTranslate() && (A = !1, n.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + m) ** C))) : m < 0 && (b && !E && i.currentTranslate < (n.centeredSlides ? s.maxTranslate() + s.size / 2 : s.maxTranslate()) && s.loopFix({
    direction: "next",
    setTranslate: !0,
    activeSlideIndex: s.slides.length - (n.slidesPerView === "auto" ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(n.slidesPerView, 10)))
  }), i.currentTranslate < s.maxTranslate() && (A = !1, n.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - m) ** C))), A && (l.preventedByNestedSwiper = !0), !s.allowSlideNext && s.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && s.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && !s.allowSlideNext && (i.currentTranslate = i.startTranslate), n.threshold > 0)
    if (Math.abs(m) > n.threshold || i.allowThresholdMove) {
      if (!i.allowThresholdMove) {
        i.allowThresholdMove = !0, a.startX = a.currentX, a.startY = a.currentY, i.currentTranslate = i.startTranslate, a.diff = s.isHorizontal() ? a.currentX - a.startX : a.currentY - a.startY;
        return;
      }
    } else {
      i.currentTranslate = i.startTranslate;
      return;
    }
  !n.followFinger || n.cssMode || ((n.freeMode && n.freeMode.enabled && s.freeMode || n.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && n.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate));
}
function onTouchEnd(e) {
  const t = this, s = t.touchEventsData, i = s.evCache.findIndex((E) => E.pointerId === e.pointerId);
  if (i >= 0 && s.evCache.splice(i, 1), ["pointercancel", "pointerout", "pointerleave"].includes(e.type))
    return;
  const {
    params: n,
    touches: a,
    rtlTranslate: r,
    slidesGrid: o,
    enabled: l
  } = t;
  if (!l || !n.simulateTouch && e.pointerType === "mouse")
    return;
  let c = e;
  if (c.originalEvent && (c = c.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", c), s.allowTouchCallbacks = !1, !s.isTouched) {
    s.isMoved && n.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, s.startMoving = !1;
    return;
  }
  n.grabCursor && s.isMoved && s.isTouched && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!1);
  const u = now(), d = u - s.touchStartTime;
  if (t.allowClick) {
    const E = c.path || c.composedPath && c.composedPath();
    t.updateClickedSlide(E && E[0] || c.target), t.emit("tap click", c), d < 300 && u - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", c);
  }
  if (s.lastClickTime = now(), nextTick(() => {
    t.destroyed || (t.allowClick = !0);
  }), !s.isTouched || !s.isMoved || !t.swipeDirection || a.diff === 0 || s.currentTranslate === s.startTranslate) {
    s.isTouched = !1, s.isMoved = !1, s.startMoving = !1;
    return;
  }
  s.isTouched = !1, s.isMoved = !1, s.startMoving = !1;
  let h;
  if (n.followFinger ? h = r ? t.translate : -t.translate : h = -s.currentTranslate, n.cssMode)
    return;
  if (t.params.freeMode && n.freeMode.enabled) {
    t.freeMode.onTouchEnd({
      currentPos: h
    });
    return;
  }
  let g = 0, p = t.slidesSizesGrid[0];
  for (let E = 0; E < o.length; E += E < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup) {
    const A = E < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup;
    typeof o[E + A] < "u" ? h >= o[E] && h < o[E + A] && (g = E, p = o[E + A] - o[E]) : h >= o[E] && (g = E, p = o[o.length - 1] - o[o.length - 2]);
  }
  let m = null, v = null;
  n.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (m = 0));
  const f = (h - o[g]) / p, b = g < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup;
  if (d > n.longSwipesMs) {
    if (!n.longSwipes) {
      t.slideTo(t.activeIndex);
      return;
    }
    t.swipeDirection === "next" && (f >= n.longSwipesRatio ? t.slideTo(n.rewind && t.isEnd ? m : g + b) : t.slideTo(g)), t.swipeDirection === "prev" && (f > 1 - n.longSwipesRatio ? t.slideTo(g + b) : v !== null && f < 0 && Math.abs(f) > n.longSwipesRatio ? t.slideTo(v) : t.slideTo(g));
  } else {
    if (!n.shortSwipes) {
      t.slideTo(t.activeIndex);
      return;
    }
    t.navigation && (c.target === t.navigation.nextEl || c.target === t.navigation.prevEl) ? c.target === t.navigation.nextEl ? t.slideTo(g + b) : t.slideTo(g) : (t.swipeDirection === "next" && t.slideTo(m !== null ? m : g + b), t.swipeDirection === "prev" && t.slideTo(v !== null ? v : g));
  }
}
let timeout;
function onResize() {
  const e = this, {
    params: t,
    el: s
  } = e;
  if (s && s.offsetWidth === 0)
    return;
  t.breakpoints && e.setBreakpoint();
  const {
    allowSlideNext: i,
    allowSlidePrev: n,
    snapGrid: a
  } = e, r = e.virtual && e.params.virtual.enabled;
  e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses();
  const o = r && t.loop;
  (t.slidesPerView === "auto" || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides && !o ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.params.loop && !r ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(timeout), timeout = setTimeout(() => {
    e.autoplay.resume();
  }, 500)), e.allowSlidePrev = n, e.allowSlideNext = i, e.params.watchOverflow && a !== e.snapGrid && e.checkOverflow();
}
function onClick(e) {
  const t = this;
  t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())));
}
function onScroll() {
  const e = this, {
    wrapperEl: t,
    rtlTranslate: s,
    enabled: i
  } = e;
  if (!i)
    return;
  e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, e.translate === 0 && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
  let n;
  const a = e.maxTranslate() - e.minTranslate();
  a === 0 ? n = 0 : n = (e.translate - e.minTranslate()) / a, n !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1);
}
const processLazyPreloader = (e, t) => {
  if (!e || e.destroyed || !e.params)
    return;
  const s = () => e.isElement ? "swiper-slide" : `.${e.params.slideClass}`, i = t.closest(s());
  if (i) {
    const n = i.querySelector(`.${e.params.lazyPreloaderClass}`);
    n && n.remove();
  }
};
function onLoad(e) {
  const t = this;
  processLazyPreloader(t, e.target), t.update();
}
let dummyEventAttached = !1;
function dummyEventListener() {
}
const events = (e, t) => {
  const s = getDocument(), {
    params: i,
    el: n,
    wrapperEl: a,
    device: r
  } = e, o = !!i.nested, l = t === "on" ? "addEventListener" : "removeEventListener", c = t;
  n[l]("pointerdown", e.onTouchStart, {
    passive: !1
  }), s[l]("pointermove", e.onTouchMove, {
    passive: !1,
    capture: o
  }), s[l]("pointerup", e.onTouchEnd, {
    passive: !0
  }), s[l]("pointercancel", e.onTouchEnd, {
    passive: !0
  }), s[l]("pointerout", e.onTouchEnd, {
    passive: !0
  }), s[l]("pointerleave", e.onTouchEnd, {
    passive: !0
  }), (i.preventClicks || i.preventClicksPropagation) && n[l]("click", e.onClick, !0), i.cssMode && a[l]("scroll", e.onScroll), i.updateOnWindowResize ? e[c](r.ios || r.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : e[c]("observerUpdate", onResize, !0), n[l]("load", e.onLoad, {
    capture: !0
  });
};
function attachEvents() {
  const e = this, t = getDocument(), {
    params: s
  } = e;
  e.onTouchStart = onTouchStart.bind(e), e.onTouchMove = onTouchMove.bind(e), e.onTouchEnd = onTouchEnd.bind(e), s.cssMode && (e.onScroll = onScroll.bind(e)), e.onClick = onClick.bind(e), e.onLoad = onLoad.bind(e), dummyEventAttached || (t.addEventListener("touchstart", dummyEventListener), dummyEventAttached = !0), events(e, "on");
}
function detachEvents() {
  events(this, "off");
}
const events$1 = {
  attachEvents,
  detachEvents
}, isGridEnabled = (e, t) => e.grid && t.grid && t.grid.rows > 1;
function setBreakpoint() {
  const e = this, {
    realIndex: t,
    initialized: s,
    params: i,
    el: n
  } = e, a = i.breakpoints;
  if (!a || a && Object.keys(a).length === 0)
    return;
  const r = e.getBreakpoint(a, e.params.breakpointsBase, e.el);
  if (!r || e.currentBreakpoint === r)
    return;
  const l = (r in a ? a[r] : void 0) || e.originalParams, c = isGridEnabled(e, i), u = isGridEnabled(e, l), d = i.enabled;
  c && !u ? (n.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && u && (n.classList.add(`${i.containerModifierClass}grid`), (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && i.grid.fill === "column") && n.classList.add(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((m) => {
    const v = i[m] && i[m].enabled, f = l[m] && l[m].enabled;
    v && !f && e[m].disable(), !v && f && e[m].enable();
  });
  const h = l.direction && l.direction !== i.direction, g = i.loop && (l.slidesPerView !== i.slidesPerView || h);
  h && s && e.changeDirection(), extend$1(e.params, l);
  const p = e.params.enabled;
  Object.assign(e, {
    allowTouchMove: e.params.allowTouchMove,
    allowSlideNext: e.params.allowSlideNext,
    allowSlidePrev: e.params.allowSlidePrev
  }), d && !p ? e.disable() : !d && p && e.enable(), e.currentBreakpoint = r, e.emit("_beforeBreakpoint", l), g && s && (e.loopDestroy(), e.loopCreate(t), e.updateSlides()), e.emit("breakpoint", l);
}
function getBreakpoint(e, t = "window", s) {
  if (!e || t === "container" && !s)
    return;
  let i = !1;
  const n = getWindow(), a = t === "window" ? n.innerHeight : s.clientHeight, r = Object.keys(e).map((o) => {
    if (typeof o == "string" && o.indexOf("@") === 0) {
      const l = parseFloat(o.substr(1));
      return {
        value: a * l,
        point: o
      };
    }
    return {
      value: o,
      point: o
    };
  });
  r.sort((o, l) => parseInt(o.value, 10) - parseInt(l.value, 10));
  for (let o = 0; o < r.length; o += 1) {
    const {
      point: l,
      value: c
    } = r[o];
    t === "window" ? n.matchMedia(`(min-width: ${c}px)`).matches && (i = l) : c <= s.clientWidth && (i = l);
  }
  return i || "max";
}
const breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(e, t) {
  const s = [];
  return e.forEach((i) => {
    typeof i == "object" ? Object.keys(i).forEach((n) => {
      i[n] && s.push(t + n);
    }) : typeof i == "string" && s.push(t + i);
  }), s;
}
function addClasses() {
  const e = this, {
    classNames: t,
    params: s,
    rtl: i,
    el: n,
    device: a
  } = e, r = prepareClasses(["initialized", s.direction, {
    "free-mode": e.params.freeMode && s.freeMode.enabled
  }, {
    autoheight: s.autoHeight
  }, {
    rtl: i
  }, {
    grid: s.grid && s.grid.rows > 1
  }, {
    "grid-column": s.grid && s.grid.rows > 1 && s.grid.fill === "column"
  }, {
    android: a.android
  }, {
    ios: a.ios
  }, {
    "css-mode": s.cssMode
  }, {
    centered: s.cssMode && s.centeredSlides
  }, {
    "watch-progress": s.watchSlidesProgress
  }], s.containerModifierClass);
  t.push(...r), n.classList.add(...t), e.emitContainerClasses();
}
function removeClasses() {
  const e = this, {
    el: t,
    classNames: s
  } = e;
  t.classList.remove(...s), e.emitContainerClasses();
}
const classes = {
  addClasses,
  removeClasses
};
function checkOverflow() {
  const e = this, {
    isLocked: t,
    params: s
  } = e, {
    slidesOffsetBefore: i
  } = s;
  if (i) {
    const n = e.slides.length - 1, a = e.slidesGrid[n] + e.slidesSizesGrid[n] + i * 2;
    e.isLocked = e.size > a;
  } else
    e.isLocked = e.snapGrid.length === 1;
  s.allowSlideNext === !0 && (e.allowSlideNext = !e.isLocked), s.allowSlidePrev === !0 && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock");
}
const checkOverflow$1 = {
  checkOverflow
}, defaults = {
  init: !0,
  direction: "horizontal",
  oneWayMovement: !1,
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: !1,
  updateOnWindowResize: !0,
  resizeObserver: !0,
  nested: !1,
  createElements: !1,
  enabled: !0,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: !1,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: !1,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: !1,
  // Set wrapper width
  setWrapperSize: !1,
  // Virtual Translate
  virtualTranslate: !1,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: !1,
  centeredSlides: !1,
  centeredSlidesBounds: !1,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: !0,
  centerInsufficientSlides: !1,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: !0,
  // Round length
  roundLengths: !1,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: !0,
  shortSwipes: !0,
  longSwipes: !0,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: !0,
  allowTouchMove: !0,
  threshold: 5,
  touchMoveStopPropagation: !1,
  touchStartPreventDefault: !0,
  touchStartForcePreventDefault: !1,
  touchReleaseOnEdges: !1,
  // Unique Navigation Elements
  uniqueNavElements: !0,
  // Resistance
  resistance: !0,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: !1,
  // Cursor
  grabCursor: !1,
  // Clicks
  preventClicks: !0,
  preventClicksPropagation: !0,
  slideToClickedSlide: !1,
  // loop
  loop: !1,
  loopedSlides: null,
  loopPreventsSliding: !0,
  // rewind
  rewind: !1,
  // Swiping/no swiping
  allowSlidePrev: !0,
  allowSlideNext: !0,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: !0,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: !0,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  // Callbacks
  runCallbacksOnInit: !0,
  // Internals
  _emitClasses: !1
};
function moduleExtendParams(e, t) {
  return function(i = {}) {
    const n = Object.keys(i)[0], a = i[n];
    if (typeof a != "object" || a === null) {
      extend$1(t, i);
      return;
    }
    if (["navigation", "pagination", "scrollbar"].indexOf(n) >= 0 && e[n] === !0 && (e[n] = {
      auto: !0
    }), !(n in e && "enabled" in a)) {
      extend$1(t, i);
      return;
    }
    e[n] === !0 && (e[n] = {
      enabled: !0
    }), typeof e[n] == "object" && !("enabled" in e[n]) && (e[n].enabled = !0), e[n] || (e[n] = {
      enabled: !1
    }), extend$1(t, i);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
}, extendedDefaults = {};
class Swiper {
  constructor(...t) {
    let s, i;
    t.length === 1 && t[0].constructor && Object.prototype.toString.call(t[0]).slice(8, -1) === "Object" ? i = t[0] : [s, i] = t, i || (i = {}), i = extend$1({}, i), s && !i.el && (i.el = s);
    const n = getDocument();
    if (i.el && typeof i.el == "string" && n.querySelectorAll(i.el).length > 1) {
      const l = [];
      return n.querySelectorAll(i.el).forEach((c) => {
        const u = extend$1({}, i, {
          el: c
        });
        l.push(new Swiper(u));
      }), l;
    }
    const a = this;
    a.__swiper__ = !0, a.support = getSupport(), a.device = getDevice({
      userAgent: i.userAgent
    }), a.browser = getBrowser(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], i.modules && Array.isArray(i.modules) && a.modules.push(...i.modules);
    const r = {};
    a.modules.forEach((l) => {
      l({
        params: i,
        swiper: a,
        extendParams: moduleExtendParams(i, r),
        on: a.on.bind(a),
        once: a.once.bind(a),
        off: a.off.bind(a),
        emit: a.emit.bind(a)
      });
    });
    const o = extend$1({}, defaults, r);
    return a.params = extend$1({}, o, extendedDefaults, i), a.originalParams = extend$1({}, a.params), a.passedParams = extend$1({}, i), a.params && a.params.on && Object.keys(a.params.on).forEach((l) => {
      a.on(l, a.params.on[l]);
    }), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, {
      enabled: a.params.enabled,
      el: s,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return a.params.direction === "horizontal";
      },
      isVertical() {
        return a.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: !0,
      isEnd: !1,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: !1,
      // Locks
      allowSlideNext: a.params.allowSlideNext,
      allowSlidePrev: a.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: a.params.focusableElements,
        // Last click time
        lastClickTime: now(),
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        evCache: []
      },
      // Clicks
      allowClick: !0,
      // Touches
      allowTouchMove: a.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    }), a.emit("_swiper"), a.params.init && a.init(), a;
  }
  recalcSlides() {
    const t = this, {
      slidesEl: s,
      params: i
    } = t;
    t.slides = elementChildren(s, `.${i.slideClass}, swiper-slide`);
  }
  enable() {
    const t = this;
    t.enabled || (t.enabled = !0, t.params.grabCursor && t.setGrabCursor(), t.emit("enable"));
  }
  disable() {
    const t = this;
    t.enabled && (t.enabled = !1, t.params.grabCursor && t.unsetGrabCursor(), t.emit("disable"));
  }
  setProgress(t, s) {
    const i = this;
    t = Math.min(Math.max(t, 0), 1);
    const n = i.minTranslate(), r = (i.maxTranslate() - n) * t + n;
    i.translateTo(r, typeof s > "u" ? 0 : s), i.updateActiveIndex(), i.updateSlidesClasses();
  }
  emitContainerClasses() {
    const t = this;
    if (!t.params._emitClasses || !t.el)
      return;
    const s = t.el.className.split(" ").filter((i) => i.indexOf("swiper") === 0 || i.indexOf(t.params.containerModifierClass) === 0);
    t.emit("_containerClasses", s.join(" "));
  }
  getSlideClasses(t) {
    const s = this;
    return s.destroyed ? "" : t.className.split(" ").filter((i) => i.indexOf("swiper-slide") === 0 || i.indexOf(s.params.slideClass) === 0).join(" ");
  }
  emitSlidesClasses() {
    const t = this;
    if (!t.params._emitClasses || !t.el)
      return;
    const s = [];
    t.slides.forEach((i) => {
      const n = t.getSlideClasses(i);
      s.push({
        slideEl: i,
        classNames: n
      }), t.emit("_slideClass", i, n);
    }), t.emit("_slideClasses", s);
  }
  slidesPerViewDynamic(t = "current", s = !1) {
    const i = this, {
      params: n,
      slides: a,
      slidesGrid: r,
      slidesSizesGrid: o,
      size: l,
      activeIndex: c
    } = i;
    let u = 1;
    if (n.centeredSlides) {
      let d = a[c].swiperSlideSize, h;
      for (let g = c + 1; g < a.length; g += 1)
        a[g] && !h && (d += a[g].swiperSlideSize, u += 1, d > l && (h = !0));
      for (let g = c - 1; g >= 0; g -= 1)
        a[g] && !h && (d += a[g].swiperSlideSize, u += 1, d > l && (h = !0));
    } else if (t === "current")
      for (let d = c + 1; d < a.length; d += 1)
        (s ? r[d] + o[d] - r[c] < l : r[d] - r[c] < l) && (u += 1);
    else
      for (let d = c - 1; d >= 0; d -= 1)
        r[c] - r[d] < l && (u += 1);
    return u;
  }
  update() {
    const t = this;
    if (!t || t.destroyed)
      return;
    const {
      snapGrid: s,
      params: i
    } = t;
    i.breakpoints && t.setBreakpoint(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach((r) => {
      r.complete && processLazyPreloader(t, r);
    }), t.updateSize(), t.updateSlides(), t.updateProgress(), t.updateSlidesClasses();
    function n() {
      const r = t.rtlTranslate ? t.translate * -1 : t.translate, o = Math.min(Math.max(r, t.maxTranslate()), t.minTranslate());
      t.setTranslate(o), t.updateActiveIndex(), t.updateSlidesClasses();
    }
    let a;
    t.params.freeMode && t.params.freeMode.enabled ? (n(), t.params.autoHeight && t.updateAutoHeight()) : ((t.params.slidesPerView === "auto" || t.params.slidesPerView > 1) && t.isEnd && !t.params.centeredSlides ? a = t.slideTo(t.slides.length - 1, 0, !1, !0) : a = t.slideTo(t.activeIndex, 0, !1, !0), a || n()), i.watchOverflow && s !== t.snapGrid && t.checkOverflow(), t.emit("update");
  }
  changeDirection(t, s = !0) {
    const i = this, n = i.params.direction;
    return t || (t = n === "horizontal" ? "vertical" : "horizontal"), t === n || t !== "horizontal" && t !== "vertical" || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`), i.el.classList.add(`${i.params.containerModifierClass}${t}`), i.emitContainerClasses(), i.params.direction = t, i.slides.forEach((a) => {
      t === "vertical" ? a.style.width = "" : a.style.height = "";
    }), i.emit("changeDirection"), s && i.update()), i;
  }
  changeLanguageDirection(t) {
    const s = this;
    s.rtl && t === "rtl" || !s.rtl && t === "ltr" || (s.rtl = t === "rtl", s.rtlTranslate = s.params.direction === "horizontal" && s.rtl, s.rtl ? (s.el.classList.add(`${s.params.containerModifierClass}rtl`), s.el.dir = "rtl") : (s.el.classList.remove(`${s.params.containerModifierClass}rtl`), s.el.dir = "ltr"), s.update());
  }
  mount(t) {
    const s = this;
    if (s.mounted)
      return !0;
    let i = t || s.params.el;
    if (typeof i == "string" && (i = document.querySelector(i)), !i)
      return !1;
    i.swiper = s, i.shadowEl && (s.isElement = !0);
    const n = () => `.${(s.params.wrapperClass || "").trim().split(" ").join(".")}`;
    let r = (() => i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(n()) : elementChildren(i, n())[0])();
    return !r && s.params.createElements && (r = createElement("div", s.params.wrapperClass), i.append(r), elementChildren(i, `.${s.params.slideClass}`).forEach((o) => {
      r.append(o);
    })), Object.assign(s, {
      el: i,
      wrapperEl: r,
      slidesEl: s.isElement ? i : r,
      mounted: !0,
      // RTL
      rtl: i.dir.toLowerCase() === "rtl" || elementStyle(i, "direction") === "rtl",
      rtlTranslate: s.params.direction === "horizontal" && (i.dir.toLowerCase() === "rtl" || elementStyle(i, "direction") === "rtl"),
      wrongRTL: elementStyle(r, "display") === "-webkit-box"
    }), !0;
  }
  init(t) {
    const s = this;
    return s.initialized || s.mount(t) === !1 || (s.emit("beforeInit"), s.params.breakpoints && s.setBreakpoint(), s.addClasses(), s.updateSize(), s.updateSlides(), s.params.watchOverflow && s.checkOverflow(), s.params.grabCursor && s.enabled && s.setGrabCursor(), s.params.loop && s.virtual && s.params.virtual.enabled ? s.slideTo(s.params.initialSlide + s.virtual.slidesBefore, 0, s.params.runCallbacksOnInit, !1, !0) : s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit, !1, !0), s.params.loop && s.loopCreate(), s.attachEvents(), [...s.el.querySelectorAll('[loading="lazy"]')].forEach((n) => {
      n.complete ? processLazyPreloader(s, n) : n.addEventListener("load", (a) => {
        processLazyPreloader(s, a.target);
      });
    }), s.initialized = !0, s.emit("init"), s.emit("afterInit")), s;
  }
  destroy(t = !0, s = !0) {
    const i = this, {
      params: n,
      el: a,
      wrapperEl: r,
      slides: o
    } = i;
    return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), s && (i.removeClasses(), a.removeAttribute("style"), r.removeAttribute("style"), o && o.length && o.forEach((l) => {
      l.classList.remove(n.slideVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass), l.removeAttribute("style"), l.removeAttribute("data-swiper-slide-index");
    })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((l) => {
      i.off(l);
    }), t !== !1 && (i.el.swiper = null, deleteProps(i)), i.destroyed = !0), null;
  }
  static extendDefaults(t) {
    extend$1(extendedDefaults, t);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(t) {
    Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []);
    const s = Swiper.prototype.__modules__;
    typeof t == "function" && s.indexOf(t) < 0 && s.push(t);
  }
  static use(t) {
    return Array.isArray(t) ? (t.forEach((s) => Swiper.installModule(s)), Swiper) : (Swiper.installModule(t), Swiper);
  }
}
Object.keys(prototypes).forEach((e) => {
  Object.keys(prototypes[e]).forEach((t) => {
    Swiper.prototype[t] = prototypes[e][t];
  });
});
Swiper.use([Resize, Observer]);
function Virtual({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  t({
    virtual: {
      enabled: !1,
      slides: [],
      cache: !0,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: !0,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let n;
  const a = getDocument();
  e.virtual = {
    cache: {},
    from: void 0,
    to: void 0,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const r = a.createElement("div");
  function o(g, p) {
    const m = e.params.virtual;
    if (m.cache && e.virtual.cache[p])
      return e.virtual.cache[p];
    let v;
    return m.renderSlide ? (v = m.renderSlide.call(e, g, p), typeof v == "string" && (r.innerHTML = v, v = r.children[0])) : e.isElement ? v = createElement("swiper-slide") : v = createElement("div", e.params.slideClass), v.setAttribute("data-swiper-slide-index", p), m.renderSlide || (v.textContent = g), m.cache && (e.virtual.cache[p] = v), v;
  }
  function l(g) {
    const {
      slidesPerView: p,
      slidesPerGroup: m,
      centeredSlides: v,
      loop: f
    } = e.params, {
      addSlidesBefore: b,
      addSlidesAfter: E
    } = e.params.virtual, {
      from: A,
      to: C,
      slides: w,
      slidesGrid: M,
      offset: k
    } = e.virtual;
    e.params.cssMode || e.updateActiveIndex();
    const O = e.activeIndex || 0;
    let z;
    e.rtlTranslate ? z = "right" : z = e.isHorizontal() ? "left" : "top";
    let S, x;
    v ? (S = Math.floor(p / 2) + m + E, x = Math.floor(p / 2) + m + b) : (S = p + (m - 1) + E, x = (f ? p : m) + b);
    let y = O - x, T = O + S;
    f || (y = Math.max(y, 0), T = Math.min(T, w.length - 1));
    let $ = (e.slidesGrid[y] || 0) - (e.slidesGrid[0] || 0);
    f && O >= x ? (y -= x, v || ($ += e.slidesGrid[0])) : f && O < x && (y = -x, v && ($ += e.slidesGrid[0])), Object.assign(e.virtual, {
      from: y,
      to: T,
      offset: $,
      slidesGrid: e.slidesGrid,
      slidesBefore: x,
      slidesAfter: S
    });
    function _() {
      e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), i("virtualUpdate");
    }
    if (A === y && C === T && !g) {
      e.slidesGrid !== M && $ !== k && e.slides.forEach((I) => {
        I.style[z] = `${$}px`;
      }), e.updateProgress(), i("virtualUpdate");
      return;
    }
    if (e.params.virtual.renderExternal) {
      e.params.virtual.renderExternal.call(e, {
        offset: $,
        from: y,
        to: T,
        slides: function() {
          const B = [];
          for (let H = y; H <= T; H += 1)
            B.push(w[H]);
          return B;
        }()
      }), e.params.virtual.renderExternalUpdate ? _() : i("virtualUpdate");
      return;
    }
    const L = [], P = [], D = (I) => {
      let B = I;
      return I < 0 ? B = w.length + I : B >= w.length && (B = B - w.length), B;
    };
    if (g)
      e.slidesEl.querySelectorAll(`.${e.params.slideClass}, swiper-slide`).forEach((I) => {
        I.remove();
      });
    else
      for (let I = A; I <= C; I += 1)
        if (I < y || I > T) {
          const B = D(I);
          e.slidesEl.querySelectorAll(`.${e.params.slideClass}[data-swiper-slide-index="${B}"], swiper-slide[data-swiper-slide-index="${B}"]`).forEach((H) => {
            H.remove();
          });
        }
    const R = f ? -w.length : 0, N = f ? w.length * 2 : w.length;
    for (let I = R; I < N; I += 1)
      if (I >= y && I <= T) {
        const B = D(I);
        typeof C > "u" || g ? P.push(B) : (I > C && P.push(B), I < A && L.push(B));
      }
    if (P.forEach((I) => {
      e.slidesEl.append(o(w[I], I));
    }), f)
      for (let I = L.length - 1; I >= 0; I -= 1) {
        const B = L[I];
        e.slidesEl.prepend(o(w[B], B));
      }
    else
      L.sort((I, B) => B - I), L.forEach((I) => {
        e.slidesEl.prepend(o(w[I], I));
      });
    elementChildren(e.slidesEl, ".swiper-slide, swiper-slide").forEach((I) => {
      I.style[z] = `${$}px`;
    }), _();
  }
  function c(g) {
    if (typeof g == "object" && "length" in g)
      for (let p = 0; p < g.length; p += 1)
        g[p] && e.virtual.slides.push(g[p]);
    else
      e.virtual.slides.push(g);
    l(!0);
  }
  function u(g) {
    const p = e.activeIndex;
    let m = p + 1, v = 1;
    if (Array.isArray(g)) {
      for (let f = 0; f < g.length; f += 1)
        g[f] && e.virtual.slides.unshift(g[f]);
      m = p + g.length, v = g.length;
    } else
      e.virtual.slides.unshift(g);
    if (e.params.virtual.cache) {
      const f = e.virtual.cache, b = {};
      Object.keys(f).forEach((E) => {
        const A = f[E], C = A.getAttribute("data-swiper-slide-index");
        C && A.setAttribute("data-swiper-slide-index", parseInt(C, 10) + v), b[parseInt(E, 10) + v] = A;
      }), e.virtual.cache = b;
    }
    l(!0), e.slideTo(m, 0);
  }
  function d(g) {
    if (typeof g > "u" || g === null)
      return;
    let p = e.activeIndex;
    if (Array.isArray(g))
      for (let m = g.length - 1; m >= 0; m -= 1)
        e.virtual.slides.splice(g[m], 1), e.params.virtual.cache && delete e.virtual.cache[g[m]], g[m] < p && (p -= 1), p = Math.max(p, 0);
    else
      e.virtual.slides.splice(g, 1), e.params.virtual.cache && delete e.virtual.cache[g], g < p && (p -= 1), p = Math.max(p, 0);
    l(!0), e.slideTo(p, 0);
  }
  function h() {
    e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), l(!0), e.slideTo(0, 0);
  }
  s("beforeInit", () => {
    if (!e.params.virtual.enabled)
      return;
    let g;
    if (typeof e.passedParams.virtual.slides > "u") {
      const p = [...e.slidesEl.children].filter((m) => m.matches(`.${e.params.slideClass}, swiper-slide`));
      p && p.length && (e.virtual.slides = [...p], g = !0, p.forEach((m, v) => {
        m.setAttribute("data-swiper-slide-index", v), e.virtual.cache[v] = m, m.remove();
      }));
    }
    g || (e.virtual.slides = e.params.virtual.slides), e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, e.params.initialSlide || l();
  }), s("setTranslate", () => {
    e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(n), n = setTimeout(() => {
      l();
    }, 100)) : l());
  }), s("init update resize", () => {
    e.params.virtual.enabled && e.params.cssMode && setCSSProperty(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`);
  }), Object.assign(e.virtual, {
    appendSlide: c,
    prependSlide: u,
    removeSlide: d,
    removeAllSlides: h,
    update: l
  });
}
function Keyboard({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  const n = getDocument(), a = getWindow();
  e.keyboard = {
    enabled: !1
  }, t({
    keyboard: {
      enabled: !1,
      onlyInViewport: !0,
      pageUpDown: !0
    }
  });
  function r(c) {
    if (!e.enabled)
      return;
    const {
      rtlTranslate: u
    } = e;
    let d = c;
    d.originalEvent && (d = d.originalEvent);
    const h = d.keyCode || d.charCode, g = e.params.keyboard.pageUpDown, p = g && h === 33, m = g && h === 34, v = h === 37, f = h === 39, b = h === 38, E = h === 40;
    if (!e.allowSlideNext && (e.isHorizontal() && f || e.isVertical() && E || m) || !e.allowSlidePrev && (e.isHorizontal() && v || e.isVertical() && b || p))
      return !1;
    if (!(d.shiftKey || d.altKey || d.ctrlKey || d.metaKey) && !(n.activeElement && n.activeElement.nodeName && (n.activeElement.nodeName.toLowerCase() === "input" || n.activeElement.nodeName.toLowerCase() === "textarea"))) {
      if (e.params.keyboard.onlyInViewport && (p || m || v || f || b || E)) {
        let A = !1;
        if (elementParents(e.el, `.${e.params.slideClass}, swiper-slide`).length > 0 && elementParents(e.el, `.${e.params.slideActiveClass}`).length === 0)
          return;
        const C = e.el, w = C.clientWidth, M = C.clientHeight, k = a.innerWidth, O = a.innerHeight, z = elementOffset(C);
        u && (z.left -= C.scrollLeft);
        const S = [[z.left, z.top], [z.left + w, z.top], [z.left, z.top + M], [z.left + w, z.top + M]];
        for (let x = 0; x < S.length; x += 1) {
          const y = S[x];
          if (y[0] >= 0 && y[0] <= k && y[1] >= 0 && y[1] <= O) {
            if (y[0] === 0 && y[1] === 0)
              continue;
            A = !0;
          }
        }
        if (!A)
          return;
      }
      e.isHorizontal() ? ((p || m || v || f) && (d.preventDefault ? d.preventDefault() : d.returnValue = !1), ((m || f) && !u || (p || v) && u) && e.slideNext(), ((p || v) && !u || (m || f) && u) && e.slidePrev()) : ((p || m || b || E) && (d.preventDefault ? d.preventDefault() : d.returnValue = !1), (m || E) && e.slideNext(), (p || b) && e.slidePrev()), i("keyPress", h);
    }
  }
  function o() {
    e.keyboard.enabled || (n.addEventListener("keydown", r), e.keyboard.enabled = !0);
  }
  function l() {
    e.keyboard.enabled && (n.removeEventListener("keydown", r), e.keyboard.enabled = !1);
  }
  s("init", () => {
    e.params.keyboard.enabled && o();
  }), s("destroy", () => {
    e.keyboard.enabled && l();
  }), Object.assign(e.keyboard, {
    enable: o,
    disable: l
  });
}
function Mousewheel({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  const n = getWindow();
  t({
    mousewheel: {
      enabled: !1,
      releaseOnEdges: !1,
      invert: !1,
      forceToAxis: !1,
      sensitivity: 1,
      eventsTarget: "container",
      thresholdDelta: null,
      thresholdTime: null
    }
  }), e.mousewheel = {
    enabled: !1
  };
  let a, r = now(), o;
  const l = [];
  function c(b) {
    let w = 0, M = 0, k = 0, O = 0;
    return "detail" in b && (M = b.detail), "wheelDelta" in b && (M = -b.wheelDelta / 120), "wheelDeltaY" in b && (M = -b.wheelDeltaY / 120), "wheelDeltaX" in b && (w = -b.wheelDeltaX / 120), "axis" in b && b.axis === b.HORIZONTAL_AXIS && (w = M, M = 0), k = w * 10, O = M * 10, "deltaY" in b && (O = b.deltaY), "deltaX" in b && (k = b.deltaX), b.shiftKey && !k && (k = O, O = 0), (k || O) && b.deltaMode && (b.deltaMode === 1 ? (k *= 40, O *= 40) : (k *= 800, O *= 800)), k && !w && (w = k < 1 ? -1 : 1), O && !M && (M = O < 1 ? -1 : 1), {
      spinX: w,
      spinY: M,
      pixelX: k,
      pixelY: O
    };
  }
  function u() {
    e.enabled && (e.mouseEntered = !0);
  }
  function d() {
    e.enabled && (e.mouseEntered = !1);
  }
  function h(b) {
    return e.params.mousewheel.thresholdDelta && b.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && now() - r < e.params.mousewheel.thresholdTime ? !1 : b.delta >= 6 && now() - r < 60 ? !0 : (b.direction < 0 ? (!e.isEnd || e.params.loop) && !e.animating && (e.slideNext(), i("scroll", b.raw)) : (!e.isBeginning || e.params.loop) && !e.animating && (e.slidePrev(), i("scroll", b.raw)), r = new n.Date().getTime(), !1);
  }
  function g(b) {
    const E = e.params.mousewheel;
    if (b.direction < 0) {
      if (e.isEnd && !e.params.loop && E.releaseOnEdges)
        return !0;
    } else if (e.isBeginning && !e.params.loop && E.releaseOnEdges)
      return !0;
    return !1;
  }
  function p(b) {
    let E = b, A = !0;
    if (!e.enabled)
      return;
    const C = e.params.mousewheel;
    e.params.cssMode && E.preventDefault();
    let w = e.el;
    e.params.mousewheel.eventsTarget !== "container" && (w = document.querySelector(e.params.mousewheel.eventsTarget));
    const M = w && w.contains(E.target);
    if (!e.mouseEntered && !M && !C.releaseOnEdges)
      return !0;
    E.originalEvent && (E = E.originalEvent);
    let k = 0;
    const O = e.rtlTranslate ? -1 : 1, z = c(E);
    if (C.forceToAxis)
      if (e.isHorizontal())
        if (Math.abs(z.pixelX) > Math.abs(z.pixelY))
          k = -z.pixelX * O;
        else
          return !0;
      else if (Math.abs(z.pixelY) > Math.abs(z.pixelX))
        k = -z.pixelY;
      else
        return !0;
    else
      k = Math.abs(z.pixelX) > Math.abs(z.pixelY) ? -z.pixelX * O : -z.pixelY;
    if (k === 0)
      return !0;
    C.invert && (k = -k);
    let S = e.getTranslate() + k * C.sensitivity;
    if (S >= e.minTranslate() && (S = e.minTranslate()), S <= e.maxTranslate() && (S = e.maxTranslate()), A = e.params.loop ? !0 : !(S === e.minTranslate() || S === e.maxTranslate()), A && e.params.nested && E.stopPropagation(), !e.params.freeMode || !e.params.freeMode.enabled) {
      const x = {
        time: now(),
        delta: Math.abs(k),
        direction: Math.sign(k),
        raw: b
      };
      l.length >= 2 && l.shift();
      const y = l.length ? l[l.length - 1] : void 0;
      if (l.push(x), y ? (x.direction !== y.direction || x.delta > y.delta || x.time > y.time + 150) && h(x) : h(x), g(x))
        return !0;
    } else {
      const x = {
        time: now(),
        delta: Math.abs(k),
        direction: Math.sign(k)
      }, y = o && x.time < o.time + 500 && x.delta <= o.delta && x.direction === o.direction;
      if (!y) {
        o = void 0;
        let T = e.getTranslate() + k * C.sensitivity;
        const $ = e.isBeginning, _ = e.isEnd;
        if (T >= e.minTranslate() && (T = e.minTranslate()), T <= e.maxTranslate() && (T = e.maxTranslate()), e.setTransition(0), e.setTranslate(T), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!$ && e.isBeginning || !_ && e.isEnd) && e.updateSlidesClasses(), e.params.loop && e.loopFix({
          direction: x.direction < 0 ? "next" : "prev",
          byMousewheel: !0
        }), e.params.freeMode.sticky) {
          clearTimeout(a), a = void 0, l.length >= 15 && l.shift();
          const L = l.length ? l[l.length - 1] : void 0, P = l[0];
          if (l.push(x), L && (x.delta > L.delta || x.direction !== L.direction))
            l.splice(0);
          else if (l.length >= 15 && x.time - P.time < 500 && P.delta - x.delta >= 1 && x.delta <= 6) {
            const D = k > 0 ? 0.8 : 0.2;
            o = x, l.splice(0), a = nextTick(() => {
              e.slideToClosest(e.params.speed, !0, void 0, D);
            }, 0);
          }
          a || (a = nextTick(() => {
            o = x, l.splice(0), e.slideToClosest(e.params.speed, !0, void 0, 0.5);
          }, 500));
        }
        if (y || i("scroll", E), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), T === e.minTranslate() || T === e.maxTranslate())
          return !0;
      }
    }
    return E.preventDefault ? E.preventDefault() : E.returnValue = !1, !1;
  }
  function m(b) {
    let E = e.el;
    e.params.mousewheel.eventsTarget !== "container" && (E = document.querySelector(e.params.mousewheel.eventsTarget)), E[b]("mouseenter", u), E[b]("mouseleave", d), E[b]("wheel", p);
  }
  function v() {
    return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", p), !0) : e.mousewheel.enabled ? !1 : (m("addEventListener"), e.mousewheel.enabled = !0, !0);
  }
  function f() {
    return e.params.cssMode ? (e.wrapperEl.addEventListener(event, p), !0) : e.mousewheel.enabled ? (m("removeEventListener"), e.mousewheel.enabled = !1, !0) : !1;
  }
  s("init", () => {
    !e.params.mousewheel.enabled && e.params.cssMode && f(), e.params.mousewheel.enabled && v();
  }), s("destroy", () => {
    e.params.cssMode && v(), e.mousewheel.enabled && f();
  }), Object.assign(e.mousewheel, {
    enable: v,
    disable: f
  });
}
function createElementIfNotDefined(e, t, s, i) {
  return e.params.createElements && Object.keys(i).forEach((n) => {
    if (!s[n] && s.auto === !0) {
      let a = elementChildren(e.el, `.${i[n]}`)[0];
      a || (a = createElement("div", i[n]), a.className = i[n], e.el.append(a)), s[n] = a, t[n] = a;
    }
  }), s;
}
function Navigation({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  t({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: !1,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled"
    }
  }), e.navigation = {
    nextEl: null,
    prevEl: null
  };
  const n = (p) => (Array.isArray(p) || (p = [p].filter((m) => !!m)), p);
  function a(p) {
    let m;
    return p && typeof p == "string" && e.isElement && (m = e.el.shadowRoot.querySelector(p), m) ? m : (p && (typeof p == "string" && (m = [...document.querySelectorAll(p)]), e.params.uniqueNavElements && typeof p == "string" && m.length > 1 && e.el.querySelectorAll(p).length === 1 && (m = e.el.querySelector(p))), p && !m ? p : m);
  }
  function r(p, m) {
    const v = e.params.navigation;
    p = n(p), p.forEach((f) => {
      f && (f.classList[m ? "add" : "remove"](...v.disabledClass.split(" ")), f.tagName === "BUTTON" && (f.disabled = m), e.params.watchOverflow && e.enabled && f.classList[e.isLocked ? "add" : "remove"](v.lockClass));
    });
  }
  function o() {
    const {
      nextEl: p,
      prevEl: m
    } = e.navigation;
    if (e.params.loop) {
      r(m, !1), r(p, !1);
      return;
    }
    r(m, e.isBeginning && !e.params.rewind), r(p, e.isEnd && !e.params.rewind);
  }
  function l(p) {
    p.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), i("navigationPrev"));
  }
  function c(p) {
    p.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), i("navigationNext"));
  }
  function u() {
    const p = e.params.navigation;
    if (e.params.navigation = createElementIfNotDefined(e, e.originalParams.navigation, e.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    }), !(p.nextEl || p.prevEl))
      return;
    let m = a(p.nextEl), v = a(p.prevEl);
    Object.assign(e.navigation, {
      nextEl: m,
      prevEl: v
    }), m = n(m), v = n(v);
    const f = (b, E) => {
      b && b.addEventListener("click", E === "next" ? c : l), !e.enabled && b && b.classList.add(...p.lockClass.split(" "));
    };
    m.forEach((b) => f(b, "next")), v.forEach((b) => f(b, "prev"));
  }
  function d() {
    let {
      nextEl: p,
      prevEl: m
    } = e.navigation;
    p = n(p), m = n(m);
    const v = (f, b) => {
      f.removeEventListener("click", b === "next" ? c : l), f.classList.remove(...e.params.navigation.disabledClass.split(" "));
    };
    p.forEach((f) => v(f, "next")), m.forEach((f) => v(f, "prev"));
  }
  s("init", () => {
    e.params.navigation.enabled === !1 ? g() : (u(), o());
  }), s("toEdge fromEdge lock unlock", () => {
    o();
  }), s("destroy", () => {
    d();
  }), s("enable disable", () => {
    let {
      nextEl: p,
      prevEl: m
    } = e.navigation;
    p = n(p), m = n(m), [...p, ...m].filter((v) => !!v).forEach((v) => v.classList[e.enabled ? "remove" : "add"](e.params.navigation.lockClass));
  }), s("click", (p, m) => {
    let {
      nextEl: v,
      prevEl: f
    } = e.navigation;
    v = n(v), f = n(f);
    const b = m.target;
    if (e.params.navigation.hideOnClick && !f.includes(b) && !v.includes(b)) {
      if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === b || e.pagination.el.contains(b)))
        return;
      let E;
      v.length ? E = v[0].classList.contains(e.params.navigation.hiddenClass) : f.length && (E = f[0].classList.contains(e.params.navigation.hiddenClass)), i(E === !0 ? "navigationShow" : "navigationHide"), [...v, ...f].filter((A) => !!A).forEach((A) => A.classList.toggle(e.params.navigation.hiddenClass));
    }
  });
  const h = () => {
    e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), u(), o();
  }, g = () => {
    e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), d();
  };
  Object.assign(e.navigation, {
    enable: h,
    disable: g,
    update: o,
    init: u,
    destroy: d
  });
}
function classesToSelector(e = "") {
  return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
}
function Pagination({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  const n = "swiper-pagination";
  t({
    pagination: {
      el: null,
      bulletElement: "span",
      clickable: !1,
      hideOnClick: !1,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: !1,
      type: "bullets",
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: !1,
      dynamicMainBullets: 1,
      formatFractionCurrent: (f) => f,
      formatFractionTotal: (f) => f,
      bulletClass: `${n}-bullet`,
      bulletActiveClass: `${n}-bullet-active`,
      modifierClass: `${n}-`,
      currentClass: `${n}-current`,
      totalClass: `${n}-total`,
      hiddenClass: `${n}-hidden`,
      progressbarFillClass: `${n}-progressbar-fill`,
      progressbarOppositeClass: `${n}-progressbar-opposite`,
      clickableClass: `${n}-clickable`,
      lockClass: `${n}-lock`,
      horizontalClass: `${n}-horizontal`,
      verticalClass: `${n}-vertical`,
      paginationDisabledClass: `${n}-disabled`
    }
  }), e.pagination = {
    el: null,
    bullets: []
  };
  let a, r = 0;
  const o = (f) => (Array.isArray(f) || (f = [f].filter((b) => !!b)), f);
  function l() {
    return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0;
  }
  function c(f, b) {
    const {
      bulletActiveClass: E
    } = e.params.pagination;
    f && (f = f[`${b === "prev" ? "previous" : "next"}ElementSibling`], f && (f.classList.add(`${E}-${b}`), f = f[`${b === "prev" ? "previous" : "next"}ElementSibling`], f && f.classList.add(`${E}-${b}-${b}`)));
  }
  function u(f) {
    const b = f.target.closest(classesToSelector(e.params.pagination.bulletClass));
    if (!b)
      return;
    f.preventDefault();
    const E = elementIndex(b) * e.params.slidesPerGroup;
    e.params.loop ? e.slideToLoop(E) : e.slideTo(E);
  }
  function d() {
    const f = e.rtl, b = e.params.pagination;
    if (l())
      return;
    let E = e.pagination.el;
    E = o(E);
    let A;
    const C = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, w = e.params.loop ? Math.ceil(C / e.params.slidesPerGroup) : e.snapGrid.length;
    if (e.params.loop ? A = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex : typeof e.snapIndex < "u" ? A = e.snapIndex : A = e.activeIndex || 0, b.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
      const M = e.pagination.bullets;
      let k, O, z;
      if (b.dynamicBullets && (a = elementOuterSize(M[0], e.isHorizontal() ? "width" : "height", !0), E.forEach((S) => {
        S.style[e.isHorizontal() ? "width" : "height"] = `${a * (b.dynamicMainBullets + 4)}px`;
      }), b.dynamicMainBullets > 1 && e.previousIndex !== void 0 && (r += A - (e.previousIndex || 0), r > b.dynamicMainBullets - 1 ? r = b.dynamicMainBullets - 1 : r < 0 && (r = 0)), k = Math.max(A - r, 0), O = k + (Math.min(M.length, b.dynamicMainBullets) - 1), z = (O + k) / 2), M.forEach((S) => {
        S.classList.remove(...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((x) => `${b.bulletActiveClass}${x}`));
      }), E.length > 1)
        M.forEach((S) => {
          const x = elementIndex(S);
          x === A && S.classList.add(b.bulletActiveClass), b.dynamicBullets && (x >= k && x <= O && S.classList.add(`${b.bulletActiveClass}-main`), x === k && c(S, "prev"), x === O && c(S, "next"));
        });
      else {
        const S = M[A];
        if (S && S.classList.add(b.bulletActiveClass), b.dynamicBullets) {
          const x = M[k], y = M[O];
          for (let T = k; T <= O; T += 1)
            M[T].classList.add(`${b.bulletActiveClass}-main`);
          c(x, "prev"), c(y, "next");
        }
      }
      if (b.dynamicBullets) {
        const S = Math.min(M.length, b.dynamicMainBullets + 4), x = (a * S - a) / 2 - z * a, y = f ? "right" : "left";
        M.forEach((T) => {
          T.style[e.isHorizontal() ? y : "top"] = `${x}px`;
        });
      }
    }
    E.forEach((M, k) => {
      if (b.type === "fraction" && (M.querySelectorAll(classesToSelector(b.currentClass)).forEach((O) => {
        O.textContent = b.formatFractionCurrent(A + 1);
      }), M.querySelectorAll(classesToSelector(b.totalClass)).forEach((O) => {
        O.textContent = b.formatFractionTotal(w);
      })), b.type === "progressbar") {
        let O;
        b.progressbarOpposite ? O = e.isHorizontal() ? "vertical" : "horizontal" : O = e.isHorizontal() ? "horizontal" : "vertical";
        const z = (A + 1) / w;
        let S = 1, x = 1;
        O === "horizontal" ? S = z : x = z, M.querySelectorAll(classesToSelector(b.progressbarFillClass)).forEach((y) => {
          y.style.transform = `translate3d(0,0,0) scaleX(${S}) scaleY(${x})`, y.style.transitionDuration = `${e.params.speed}ms`;
        });
      }
      b.type === "custom" && b.renderCustom ? (M.innerHTML = b.renderCustom(e, A + 1, w), k === 0 && i("paginationRender", M)) : (k === 0 && i("paginationRender", M), i("paginationUpdate", M)), e.params.watchOverflow && e.enabled && M.classList[e.isLocked ? "add" : "remove"](b.lockClass);
    });
  }
  function h() {
    const f = e.params.pagination;
    if (l())
      return;
    const b = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length;
    let E = e.pagination.el;
    E = o(E);
    let A = "";
    if (f.type === "bullets") {
      let C = e.params.loop ? Math.ceil(b / e.params.slidesPerGroup) : e.snapGrid.length;
      e.params.freeMode && e.params.freeMode.enabled && C > b && (C = b);
      for (let w = 0; w < C; w += 1)
        f.renderBullet ? A += f.renderBullet.call(e, w, f.bulletClass) : A += `<${f.bulletElement} class="${f.bulletClass}"></${f.bulletElement}>`;
    }
    f.type === "fraction" && (f.renderFraction ? A = f.renderFraction.call(e, f.currentClass, f.totalClass) : A = `<span class="${f.currentClass}"></span> / <span class="${f.totalClass}"></span>`), f.type === "progressbar" && (f.renderProgressbar ? A = f.renderProgressbar.call(e, f.progressbarFillClass) : A = `<span class="${f.progressbarFillClass}"></span>`), E.forEach((C) => {
      f.type !== "custom" && (C.innerHTML = A || ""), f.type === "bullets" && (e.pagination.bullets = [...C.querySelectorAll(classesToSelector(f.bulletClass))]);
    }), f.type !== "custom" && i("paginationRender", E[0]);
  }
  function g() {
    e.params.pagination = createElementIfNotDefined(e, e.originalParams.pagination, e.params.pagination, {
      el: "swiper-pagination"
    });
    const f = e.params.pagination;
    if (!f.el)
      return;
    let b;
    typeof f.el == "string" && e.isElement && (b = e.el.shadowRoot.querySelector(f.el)), !b && typeof f.el == "string" && (b = [...document.querySelectorAll(f.el)]), b || (b = f.el), !(!b || b.length === 0) && (e.params.uniqueNavElements && typeof f.el == "string" && Array.isArray(b) && b.length > 1 && (b = [...e.el.querySelectorAll(f.el)], b.length > 1 && (b = b.filter((E) => elementParents(E, ".swiper")[0] === e.el)[0])), Array.isArray(b) && b.length === 1 && (b = b[0]), Object.assign(e.pagination, {
      el: b
    }), b = o(b), b.forEach((E) => {
      f.type === "bullets" && f.clickable && E.classList.add(f.clickableClass), E.classList.add(f.modifierClass + f.type), E.classList.add(e.isHorizontal() ? f.horizontalClass : f.verticalClass), f.type === "bullets" && f.dynamicBullets && (E.classList.add(`${f.modifierClass}${f.type}-dynamic`), r = 0, f.dynamicMainBullets < 1 && (f.dynamicMainBullets = 1)), f.type === "progressbar" && f.progressbarOpposite && E.classList.add(f.progressbarOppositeClass), f.clickable && E.addEventListener("click", u), e.enabled || E.classList.add(f.lockClass);
    }));
  }
  function p() {
    const f = e.params.pagination;
    if (l())
      return;
    let b = e.pagination.el;
    b && (b = o(b), b.forEach((E) => {
      E.classList.remove(f.hiddenClass), E.classList.remove(f.modifierClass + f.type), E.classList.remove(e.isHorizontal() ? f.horizontalClass : f.verticalClass), f.clickable && E.removeEventListener("click", u);
    })), e.pagination.bullets && e.pagination.bullets.forEach((E) => E.classList.remove(f.bulletActiveClass));
  }
  s("init", () => {
    e.params.pagination.enabled === !1 ? v() : (g(), h(), d());
  }), s("activeIndexChange", () => {
    typeof e.snapIndex > "u" && d();
  }), s("snapIndexChange", () => {
    d();
  }), s("snapGridLengthChange", () => {
    h(), d();
  }), s("destroy", () => {
    p();
  }), s("enable disable", () => {
    let {
      el: f
    } = e.pagination;
    f && (f = o(f), f.forEach((b) => b.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass)));
  }), s("lock unlock", () => {
    d();
  }), s("click", (f, b) => {
    const E = b.target;
    let {
      el: A
    } = e.pagination;
    if (Array.isArray(A) || (A = [A].filter((C) => !!C)), e.params.pagination.el && e.params.pagination.hideOnClick && A && A.length > 0 && !E.classList.contains(e.params.pagination.bulletClass)) {
      if (e.navigation && (e.navigation.nextEl && E === e.navigation.nextEl || e.navigation.prevEl && E === e.navigation.prevEl))
        return;
      const C = A[0].classList.contains(e.params.pagination.hiddenClass);
      i(C === !0 ? "paginationShow" : "paginationHide"), A.forEach((w) => w.classList.toggle(e.params.pagination.hiddenClass));
    }
  });
  const m = () => {
    e.el.classList.remove(e.params.pagination.paginationDisabledClass);
    let {
      el: f
    } = e.pagination;
    f && (f = o(f), f.forEach((b) => b.classList.remove(e.params.pagination.paginationDisabledClass))), g(), h(), d();
  }, v = () => {
    e.el.classList.add(e.params.pagination.paginationDisabledClass);
    let {
      el: f
    } = e.pagination;
    f && (f = o(f), f.forEach((b) => b.classList.add(e.params.pagination.paginationDisabledClass))), p();
  };
  Object.assign(e.pagination, {
    enable: m,
    disable: v,
    render: h,
    update: d,
    init: g,
    destroy: p
  });
}
function Scrollbar({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  const n = getDocument();
  let a = !1, r = null, o = null, l, c, u, d;
  t({
    scrollbar: {
      el: null,
      dragSize: "auto",
      hide: !1,
      draggable: !1,
      snapOnRelease: !0,
      lockClass: "swiper-scrollbar-lock",
      dragClass: "swiper-scrollbar-drag",
      scrollbarDisabledClass: "swiper-scrollbar-disabled",
      horizontalClass: "swiper-scrollbar-horizontal",
      verticalClass: "swiper-scrollbar-vertical"
    }
  }), e.scrollbar = {
    el: null,
    dragEl: null
  };
  function h() {
    if (!e.params.scrollbar.el || !e.scrollbar.el)
      return;
    const {
      scrollbar: S,
      rtlTranslate: x
    } = e, {
      dragEl: y,
      el: T
    } = S, $ = e.params.scrollbar, _ = e.params.loop ? e.progressLoop : e.progress;
    let L = c, P = (u - c) * _;
    x ? (P = -P, P > 0 ? (L = c - P, P = 0) : -P + c > u && (L = u + P)) : P < 0 ? (L = c + P, P = 0) : P + c > u && (L = u - P), e.isHorizontal() ? (y.style.transform = `translate3d(${P}px, 0, 0)`, y.style.width = `${L}px`) : (y.style.transform = `translate3d(0px, ${P}px, 0)`, y.style.height = `${L}px`), $.hide && (clearTimeout(r), T.style.opacity = 1, r = setTimeout(() => {
      T.style.opacity = 0, T.style.transitionDuration = "400ms";
    }, 1e3));
  }
  function g(S) {
    !e.params.scrollbar.el || !e.scrollbar.el || (e.scrollbar.dragEl.style.transitionDuration = `${S}ms`);
  }
  function p() {
    if (!e.params.scrollbar.el || !e.scrollbar.el)
      return;
    const {
      scrollbar: S
    } = e, {
      dragEl: x,
      el: y
    } = S;
    x.style.width = "", x.style.height = "", u = e.isHorizontal() ? y.offsetWidth : y.offsetHeight, d = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), e.params.scrollbar.dragSize === "auto" ? c = u * d : c = parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? x.style.width = `${c}px` : x.style.height = `${c}px`, d >= 1 ? y.style.display = "none" : y.style.display = "", e.params.scrollbar.hide && (y.style.opacity = 0), e.params.watchOverflow && e.enabled && S.el.classList[e.isLocked ? "add" : "remove"](e.params.scrollbar.lockClass);
  }
  function m(S) {
    return e.isHorizontal() ? S.clientX : S.clientY;
  }
  function v(S) {
    const {
      scrollbar: x,
      rtlTranslate: y
    } = e, {
      el: T
    } = x;
    let $;
    $ = (m(S) - elementOffset(T)[e.isHorizontal() ? "left" : "top"] - (l !== null ? l : c / 2)) / (u - c), $ = Math.max(Math.min($, 1), 0), y && ($ = 1 - $);
    const _ = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * $;
    e.updateProgress(_), e.setTranslate(_), e.updateActiveIndex(), e.updateSlidesClasses();
  }
  function f(S) {
    const x = e.params.scrollbar, {
      scrollbar: y,
      wrapperEl: T
    } = e, {
      el: $,
      dragEl: _
    } = y;
    a = !0, l = S.target === _ ? m(S) - S.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, S.preventDefault(), S.stopPropagation(), T.style.transitionDuration = "100ms", _.style.transitionDuration = "100ms", v(S), clearTimeout(o), $.style.transitionDuration = "0ms", x.hide && ($.style.opacity = 1), e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "none"), i("scrollbarDragStart", S);
  }
  function b(S) {
    const {
      scrollbar: x,
      wrapperEl: y
    } = e, {
      el: T,
      dragEl: $
    } = x;
    a && (S.preventDefault ? S.preventDefault() : S.returnValue = !1, v(S), y.style.transitionDuration = "0ms", T.style.transitionDuration = "0ms", $.style.transitionDuration = "0ms", i("scrollbarDragMove", S));
  }
  function E(S) {
    const x = e.params.scrollbar, {
      scrollbar: y,
      wrapperEl: T
    } = e, {
      el: $
    } = y;
    a && (a = !1, e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "", T.style.transitionDuration = ""), x.hide && (clearTimeout(o), o = nextTick(() => {
      $.style.opacity = 0, $.style.transitionDuration = "400ms";
    }, 1e3)), i("scrollbarDragEnd", S), x.snapOnRelease && e.slideToClosest());
  }
  function A(S) {
    const {
      scrollbar: x,
      params: y
    } = e, T = x.el;
    if (!T)
      return;
    const $ = T, _ = y.passiveListeners ? {
      passive: !1,
      capture: !1
    } : !1, L = y.passiveListeners ? {
      passive: !0,
      capture: !1
    } : !1;
    if (!$)
      return;
    const P = S === "on" ? "addEventListener" : "removeEventListener";
    $[P]("pointerdown", f, _), n[P]("pointermove", b, _), n[P]("pointerup", E, L);
  }
  function C() {
    !e.params.scrollbar.el || !e.scrollbar.el || A("on");
  }
  function w() {
    !e.params.scrollbar.el || !e.scrollbar.el || A("off");
  }
  function M() {
    const {
      scrollbar: S,
      el: x
    } = e;
    e.params.scrollbar = createElementIfNotDefined(e, e.originalParams.scrollbar, e.params.scrollbar, {
      el: "swiper-scrollbar"
    });
    const y = e.params.scrollbar;
    if (!y.el)
      return;
    let T;
    typeof y.el == "string" && e.isElement && (T = e.el.shadowRoot.querySelector(y.el)), !T && typeof y.el == "string" ? T = n.querySelectorAll(y.el) : T || (T = y.el), e.params.uniqueNavElements && typeof y.el == "string" && T.length > 1 && x.querySelectorAll(y.el).length === 1 && (T = x.querySelector(y.el)), T.length > 0 && (T = T[0]), T.classList.add(e.isHorizontal() ? y.horizontalClass : y.verticalClass);
    let $;
    T && ($ = T.querySelector(`.${e.params.scrollbar.dragClass}`), $ || ($ = createElement("div", e.params.scrollbar.dragClass), T.append($))), Object.assign(S, {
      el: T,
      dragEl: $
    }), y.draggable && C(), T && T.classList[e.enabled ? "remove" : "add"](e.params.scrollbar.lockClass);
  }
  function k() {
    const S = e.params.scrollbar, x = e.scrollbar.el;
    x && x.classList.remove(e.isHorizontal() ? S.horizontalClass : S.verticalClass), w();
  }
  s("init", () => {
    e.params.scrollbar.enabled === !1 ? z() : (M(), p(), h());
  }), s("update resize observerUpdate lock unlock", () => {
    p();
  }), s("setTranslate", () => {
    h();
  }), s("setTransition", (S, x) => {
    g(x);
  }), s("enable disable", () => {
    const {
      el: S
    } = e.scrollbar;
    S && S.classList[e.enabled ? "remove" : "add"](e.params.scrollbar.lockClass);
  }), s("destroy", () => {
    k();
  });
  const O = () => {
    e.el.classList.remove(e.params.scrollbar.scrollbarDisabledClass), e.scrollbar.el && e.scrollbar.el.classList.remove(e.params.scrollbar.scrollbarDisabledClass), M(), p(), h();
  }, z = () => {
    e.el.classList.add(e.params.scrollbar.scrollbarDisabledClass), e.scrollbar.el && e.scrollbar.el.classList.add(e.params.scrollbar.scrollbarDisabledClass), k();
  };
  Object.assign(e.scrollbar, {
    enable: O,
    disable: z,
    updateSize: p,
    setTranslate: h,
    init: M,
    destroy: k
  });
}
function Parallax({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    parallax: {
      enabled: !1
    }
  });
  const i = (r, o) => {
    const {
      rtl: l
    } = e, c = l ? -1 : 1, u = r.getAttribute("data-swiper-parallax") || "0";
    let d = r.getAttribute("data-swiper-parallax-x"), h = r.getAttribute("data-swiper-parallax-y");
    const g = r.getAttribute("data-swiper-parallax-scale"), p = r.getAttribute("data-swiper-parallax-opacity"), m = r.getAttribute("data-swiper-parallax-rotate");
    if (d || h ? (d = d || "0", h = h || "0") : e.isHorizontal() ? (d = u, h = "0") : (h = u, d = "0"), d.indexOf("%") >= 0 ? d = `${parseInt(d, 10) * o * c}%` : d = `${d * o * c}px`, h.indexOf("%") >= 0 ? h = `${parseInt(h, 10) * o}%` : h = `${h * o}px`, typeof p < "u" && p !== null) {
      const f = p - (p - 1) * (1 - Math.abs(o));
      r.style.opacity = f;
    }
    let v = `translate3d(${d}, ${h}, 0px)`;
    if (typeof g < "u" && g !== null) {
      const f = g - (g - 1) * (1 - Math.abs(o));
      v += ` scale(${f})`;
    }
    if (m && typeof m < "u" && m !== null) {
      const f = m * o * -1;
      v += ` rotate(${f}deg)`;
    }
    r.style.transform = v;
  }, n = () => {
    const {
      el: r,
      slides: o,
      progress: l,
      snapGrid: c
    } = e;
    elementChildren(r, "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").forEach((u) => {
      i(u, l);
    }), o.forEach((u, d) => {
      let h = u.progress;
      e.params.slidesPerGroup > 1 && e.params.slidesPerView !== "auto" && (h += Math.ceil(d / 2) - l * (c.length - 1)), h = Math.min(Math.max(h, -1), 1), u.querySelectorAll("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]").forEach((g) => {
        i(g, h);
      });
    });
  }, a = (r = e.params.speed) => {
    const {
      el: o
    } = e;
    o.querySelectorAll("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").forEach((l) => {
      let c = parseInt(l.getAttribute("data-swiper-parallax-duration"), 10) || r;
      r === 0 && (c = 0), l.style.transitionDuration = `${c}ms`;
    });
  };
  s("beforeInit", () => {
    e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0);
  }), s("init", () => {
    e.params.parallax.enabled && n();
  }), s("setTranslate", () => {
    e.params.parallax.enabled && n();
  }), s("setTransition", (r, o) => {
    e.params.parallax.enabled && a(o);
  });
}
function Zoom({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i
}) {
  const n = getWindow();
  t({
    zoom: {
      enabled: !1,
      maxRatio: 3,
      minRatio: 1,
      toggle: !0,
      containerClass: "swiper-zoom-container",
      zoomedSlideClass: "swiper-slide-zoomed"
    }
  }), e.zoom = {
    enabled: !1
  };
  let a = 1, r = !1, o, l;
  const c = [], u = {
    slideEl: void 0,
    slideWidth: void 0,
    slideHeight: void 0,
    imageEl: void 0,
    imageWrapEl: void 0,
    maxRatio: 3
  }, d = {
    isTouched: void 0,
    isMoved: void 0,
    currentX: void 0,
    currentY: void 0,
    minX: void 0,
    minY: void 0,
    maxX: void 0,
    maxY: void 0,
    width: void 0,
    height: void 0,
    startX: void 0,
    startY: void 0,
    touchesStart: {},
    touchesCurrent: {}
  }, h = {
    x: void 0,
    y: void 0,
    prevPositionX: void 0,
    prevPositionY: void 0,
    prevTime: void 0
  };
  let g = 1;
  Object.defineProperty(e.zoom, "scale", {
    get() {
      return g;
    },
    set(_) {
      if (g !== _) {
        const L = u.imageEl, P = u.slideEl;
        i("zoomChange", _, L, P);
      }
      g = _;
    }
  });
  function p() {
    if (c.length < 2)
      return 1;
    const _ = c[0].pageX, L = c[0].pageY, P = c[1].pageX, D = c[1].pageY;
    return Math.sqrt((P - _) ** 2 + (D - L) ** 2);
  }
  function m() {
    if (c.length < 2)
      return {
        x: null,
        y: null
      };
    const _ = u.imageEl.getBoundingClientRect();
    return [(c[0].pageX + (c[1].pageX - c[0].pageX) / 2 - _.x) / a, (c[0].pageY + (c[1].pageY - c[0].pageY) / 2 - _.y) / a];
  }
  function v() {
    return e.isElement ? "swiper-slide" : `.${e.params.slideClass}`;
  }
  function f(_) {
    const L = v();
    return !!(_.target.matches(L) || e.slides.filter((P) => P.contains(_.target)).length > 0);
  }
  function b(_) {
    const L = `.${e.params.zoom.containerClass}`;
    return !!(_.target.matches(L) || [...e.el.querySelectorAll(L)].filter((P) => P.contains(_.target)).length > 0);
  }
  function E(_) {
    if (!f(_))
      return;
    const L = e.params.zoom;
    if (o = !1, l = !1, c.push(_), !(c.length < 2)) {
      if (o = !0, u.scaleStart = p(), !u.slideEl) {
        u.slideEl = _.target.closest(`.${e.params.slideClass}, swiper-slide`), u.slideEl || (u.slideEl = e.slides[e.activeIndex]);
        let P = u.slideEl.querySelector(`.${L.containerClass}`);
        if (P && (P = P.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = P, P ? u.imageWrapEl = elementParents(u.imageEl, `.${L.containerClass}`)[0] : u.imageWrapEl = void 0, !u.imageWrapEl) {
          u.imageEl = void 0;
          return;
        }
        u.maxRatio = u.imageWrapEl.getAttribute("data-swiper-zoom") || L.maxRatio;
      }
      if (u.imageEl) {
        const [P, D] = m();
        u.imageEl.style.transformOrigin = `${P}px ${D}px`, u.imageEl.style.transitionDuration = "0ms";
      }
      r = !0;
    }
  }
  function A(_) {
    if (!f(_))
      return;
    const L = e.params.zoom, P = e.zoom, D = c.findIndex((R) => R.pointerId === _.pointerId);
    D >= 0 && (c[D] = _), !(c.length < 2) && (l = !0, u.scaleMove = p(), u.imageEl && (P.scale = u.scaleMove / u.scaleStart * a, P.scale > u.maxRatio && (P.scale = u.maxRatio - 1 + (P.scale - u.maxRatio + 1) ** 0.5), P.scale < L.minRatio && (P.scale = L.minRatio + 1 - (L.minRatio - P.scale + 1) ** 0.5), u.imageEl.style.transform = `translate3d(0,0,0) scale(${P.scale})`));
  }
  function C(_) {
    if (!f(_))
      return;
    const L = e.params.zoom, P = e.zoom, D = c.findIndex((R) => R.pointerId === _.pointerId);
    D >= 0 && c.splice(D, 1), !(!o || !l) && (o = !1, l = !1, u.imageEl && (P.scale = Math.max(Math.min(P.scale, u.maxRatio), L.minRatio), u.imageEl.style.transitionDuration = `${e.params.speed}ms`, u.imageEl.style.transform = `translate3d(0,0,0) scale(${P.scale})`, a = P.scale, r = !1, P.scale === 1 && (u.slideEl = void 0)));
  }
  function w(_) {
    const L = e.device;
    u.imageEl && (d.isTouched || (L.android && _.cancelable && _.preventDefault(), d.isTouched = !0, d.touchesStart.x = _.pageX, d.touchesStart.y = _.pageY));
  }
  function M(_) {
    if (!f(_) || !b(_))
      return;
    const L = e.zoom;
    if (!u.imageEl || (e.allowClick = !1, !d.isTouched || !u.slideEl))
      return;
    d.isMoved || (d.width = u.imageEl.offsetWidth, d.height = u.imageEl.offsetHeight, d.startX = getTranslate(u.imageWrapEl, "x") || 0, d.startY = getTranslate(u.imageWrapEl, "y") || 0, u.slideWidth = u.slideEl.offsetWidth, u.slideHeight = u.slideEl.offsetHeight, u.imageWrapEl.style.transitionDuration = "0ms");
    const P = d.width * L.scale, D = d.height * L.scale;
    if (!(P < u.slideWidth && D < u.slideHeight)) {
      if (d.minX = Math.min(u.slideWidth / 2 - P / 2, 0), d.maxX = -d.minX, d.minY = Math.min(u.slideHeight / 2 - D / 2, 0), d.maxY = -d.minY, d.touchesCurrent.x = c.length > 0 ? c[0].pageX : _.pageX, d.touchesCurrent.y = c.length > 0 ? c[0].pageY : _.pageY, !d.isMoved && !r) {
        if (e.isHorizontal() && (Math.floor(d.minX) === Math.floor(d.startX) && d.touchesCurrent.x < d.touchesStart.x || Math.floor(d.maxX) === Math.floor(d.startX) && d.touchesCurrent.x > d.touchesStart.x)) {
          d.isTouched = !1;
          return;
        }
        if (!e.isHorizontal() && (Math.floor(d.minY) === Math.floor(d.startY) && d.touchesCurrent.y < d.touchesStart.y || Math.floor(d.maxY) === Math.floor(d.startY) && d.touchesCurrent.y > d.touchesStart.y)) {
          d.isTouched = !1;
          return;
        }
      }
      _.cancelable && _.preventDefault(), _.stopPropagation(), d.isMoved = !0, d.currentX = d.touchesCurrent.x - d.touchesStart.x + d.startX, d.currentY = d.touchesCurrent.y - d.touchesStart.y + d.startY, d.currentX < d.minX && (d.currentX = d.minX + 1 - (d.minX - d.currentX + 1) ** 0.8), d.currentX > d.maxX && (d.currentX = d.maxX - 1 + (d.currentX - d.maxX + 1) ** 0.8), d.currentY < d.minY && (d.currentY = d.minY + 1 - (d.minY - d.currentY + 1) ** 0.8), d.currentY > d.maxY && (d.currentY = d.maxY - 1 + (d.currentY - d.maxY + 1) ** 0.8), h.prevPositionX || (h.prevPositionX = d.touchesCurrent.x), h.prevPositionY || (h.prevPositionY = d.touchesCurrent.y), h.prevTime || (h.prevTime = Date.now()), h.x = (d.touchesCurrent.x - h.prevPositionX) / (Date.now() - h.prevTime) / 2, h.y = (d.touchesCurrent.y - h.prevPositionY) / (Date.now() - h.prevTime) / 2, Math.abs(d.touchesCurrent.x - h.prevPositionX) < 2 && (h.x = 0), Math.abs(d.touchesCurrent.y - h.prevPositionY) < 2 && (h.y = 0), h.prevPositionX = d.touchesCurrent.x, h.prevPositionY = d.touchesCurrent.y, h.prevTime = Date.now(), u.imageWrapEl.style.transform = `translate3d(${d.currentX}px, ${d.currentY}px,0)`;
    }
  }
  function k() {
    const _ = e.zoom;
    if (!u.imageEl)
      return;
    if (!d.isTouched || !d.isMoved) {
      d.isTouched = !1, d.isMoved = !1;
      return;
    }
    d.isTouched = !1, d.isMoved = !1;
    let L = 300, P = 300;
    const D = h.x * L, R = d.currentX + D, N = h.y * P, I = d.currentY + N;
    h.x !== 0 && (L = Math.abs((R - d.currentX) / h.x)), h.y !== 0 && (P = Math.abs((I - d.currentY) / h.y));
    const B = Math.max(L, P);
    d.currentX = R, d.currentY = I;
    const H = d.width * _.scale, q = d.height * _.scale;
    d.minX = Math.min(u.slideWidth / 2 - H / 2, 0), d.maxX = -d.minX, d.minY = Math.min(u.slideHeight / 2 - q / 2, 0), d.maxY = -d.minY, d.currentX = Math.max(Math.min(d.currentX, d.maxX), d.minX), d.currentY = Math.max(Math.min(d.currentY, d.maxY), d.minY), u.imageWrapEl.style.transitionDuration = `${B}ms`, u.imageWrapEl.style.transform = `translate3d(${d.currentX}px, ${d.currentY}px,0)`;
  }
  function O() {
    const _ = e.zoom;
    u.slideEl && e.previousIndex !== e.activeIndex && (u.imageEl && (u.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), u.imageWrapEl && (u.imageWrapEl.style.transform = "translate3d(0,0,0)"), _.scale = 1, a = 1, u.slideEl = void 0, u.imageEl = void 0, u.imageWrapEl = void 0);
  }
  function z(_) {
    const L = e.zoom, P = e.params.zoom;
    if (!u.slideEl) {
      _ && _.target && (u.slideEl = _.target.closest(`.${e.params.slideClass}, swiper-slide`)), u.slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.slideEl = elementChildren(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : u.slideEl = e.slides[e.activeIndex]);
      let G = u.slideEl.querySelector(`.${P.containerClass}`);
      G && (G = G.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = G, G ? u.imageWrapEl = elementParents(u.imageEl, `.${P.containerClass}`)[0] : u.imageWrapEl = void 0;
    }
    if (!u.imageEl || !u.imageWrapEl)
      return;
    e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), u.slideEl.classList.add(`${P.zoomedSlideClass}`);
    let D, R, N, I, B, H, q, F, J, Z, Q, ee, j, Y, U, W, X, K;
    typeof d.touchesStart.x > "u" && _ ? (D = _.pageX, R = _.pageY) : (D = d.touchesStart.x, R = d.touchesStart.y);
    const V = typeof _ == "number" ? _ : null;
    a === 1 && V && (D = void 0, R = void 0), L.scale = V || u.imageWrapEl.getAttribute("data-swiper-zoom") || P.maxRatio, a = V || u.imageWrapEl.getAttribute("data-swiper-zoom") || P.maxRatio, _ && !(a === 1 && V) ? (X = u.slideEl.offsetWidth, K = u.slideEl.offsetHeight, N = elementOffset(u.slideEl).left + n.scrollX, I = elementOffset(u.slideEl).top + n.scrollY, B = N + X / 2 - D, H = I + K / 2 - R, J = u.imageEl.offsetWidth, Z = u.imageEl.offsetHeight, Q = J * L.scale, ee = Z * L.scale, j = Math.min(X / 2 - Q / 2, 0), Y = Math.min(K / 2 - ee / 2, 0), U = -j, W = -Y, q = B * L.scale, F = H * L.scale, q < j && (q = j), q > U && (q = U), F < Y && (F = Y), F > W && (F = W)) : (q = 0, F = 0), u.imageWrapEl.style.transitionDuration = "300ms", u.imageWrapEl.style.transform = `translate3d(${q}px, ${F}px,0)`, u.imageEl.style.transitionDuration = "300ms", u.imageEl.style.transform = `translate3d(0,0,0) scale(${L.scale})`;
  }
  function S() {
    const _ = e.zoom, L = e.params.zoom;
    if (!u.slideEl) {
      e.params.virtual && e.params.virtual.enabled && e.virtual ? u.slideEl = elementChildren(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : u.slideEl = e.slides[e.activeIndex];
      let P = u.slideEl.querySelector(`.${L.containerClass}`);
      P && (P = P.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = P, P ? u.imageWrapEl = elementParents(u.imageEl, `.${L.containerClass}`)[0] : u.imageWrapEl = void 0;
    }
    !u.imageEl || !u.imageWrapEl || (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), _.scale = 1, a = 1, u.imageWrapEl.style.transitionDuration = "300ms", u.imageWrapEl.style.transform = "translate3d(0,0,0)", u.imageEl.style.transitionDuration = "300ms", u.imageEl.style.transform = "translate3d(0,0,0) scale(1)", u.slideEl.classList.remove(`${L.zoomedSlideClass}`), u.slideEl = void 0);
  }
  function x(_) {
    const L = e.zoom;
    L.scale && L.scale !== 1 ? S() : z(_);
  }
  function y() {
    const _ = e.params.passiveListeners ? {
      passive: !0,
      capture: !1
    } : !1, L = e.params.passiveListeners ? {
      passive: !1,
      capture: !0
    } : !0;
    return {
      passiveListener: _,
      activeListenerWithCapture: L
    };
  }
  function T() {
    const _ = e.zoom;
    if (_.enabled)
      return;
    _.enabled = !0;
    const {
      passiveListener: L,
      activeListenerWithCapture: P
    } = y();
    e.wrapperEl.addEventListener("pointerdown", E, L), e.wrapperEl.addEventListener("pointermove", A, P), ["pointerup", "pointercancel"].forEach((D) => {
      e.wrapperEl.addEventListener(D, C, L);
    }), e.wrapperEl.addEventListener("pointermove", M, P);
  }
  function $() {
    const _ = e.zoom;
    if (!_.enabled)
      return;
    _.enabled = !1;
    const {
      passiveListener: L,
      activeListenerWithCapture: P
    } = y();
    e.wrapperEl.removeEventListener("pointerdown", E, L), e.wrapperEl.removeEventListener("pointermove", A, P), ["pointerup", "pointercancel"].forEach((D) => {
      e.wrapperEl.removeEventListener(D, C, L);
    }), e.wrapperEl.removeEventListener("pointermove", M, P);
  }
  s("init", () => {
    e.params.zoom.enabled && T();
  }), s("destroy", () => {
    $();
  }), s("touchStart", (_, L) => {
    e.zoom.enabled && w(L);
  }), s("touchEnd", (_, L) => {
    e.zoom.enabled && k();
  }), s("doubleTap", (_, L) => {
    !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && x(L);
  }), s("transitionEnd", () => {
    e.zoom.enabled && e.params.zoom.enabled && O();
  }), s("slideChange", () => {
    e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && O();
  }), Object.assign(e.zoom, {
    enable: T,
    disable: $,
    in: z,
    out: S,
    toggle: x
  });
}
function Controller({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    controller: {
      control: void 0,
      inverse: !1,
      by: "slide"
      // or 'container'
    }
  }), e.controller = {
    control: void 0
  };
  function i(l, c) {
    const u = function() {
      let p, m, v;
      return (f, b) => {
        for (m = -1, p = f.length; p - m > 1; )
          v = p + m >> 1, f[v] <= b ? m = v : p = v;
        return p;
      };
    }();
    this.x = l, this.y = c, this.lastIndex = l.length - 1;
    let d, h;
    return this.interpolate = function(p) {
      return p ? (h = u(this.x, p), d = h - 1, (p - this.x[d]) * (this.y[h] - this.y[d]) / (this.x[h] - this.x[d]) + this.y[d]) : 0;
    }, this;
  }
  function n(l) {
    e.controller.spline || (e.controller.spline = e.params.loop ? new i(e.slidesGrid, l.slidesGrid) : new i(e.snapGrid, l.snapGrid));
  }
  function a(l, c) {
    const u = e.controller.control;
    let d, h;
    const g = e.constructor;
    function p(m) {
      const v = e.rtlTranslate ? -e.translate : e.translate;
      e.params.controller.by === "slide" && (n(m), h = -e.controller.spline.interpolate(-v)), (!h || e.params.controller.by === "container") && (d = (m.maxTranslate() - m.minTranslate()) / (e.maxTranslate() - e.minTranslate()), h = (v - e.minTranslate()) * d + m.minTranslate()), e.params.controller.inverse && (h = m.maxTranslate() - h), m.updateProgress(h), m.setTranslate(h, e), m.updateActiveIndex(), m.updateSlidesClasses();
    }
    if (Array.isArray(u))
      for (let m = 0; m < u.length; m += 1)
        u[m] !== c && u[m] instanceof g && p(u[m]);
    else
      u instanceof g && c !== u && p(u);
  }
  function r(l, c) {
    const u = e.constructor, d = e.controller.control;
    let h;
    function g(p) {
      p.setTransition(l, e), l !== 0 && (p.transitionStart(), p.params.autoHeight && nextTick(() => {
        p.updateAutoHeight();
      }), elementTransitionEnd(p.wrapperEl, () => {
        d && p.transitionEnd();
      }));
    }
    if (Array.isArray(d))
      for (h = 0; h < d.length; h += 1)
        d[h] !== c && d[h] instanceof u && g(d[h]);
    else
      d instanceof u && c !== d && g(d);
  }
  function o() {
    e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline);
  }
  s("beforeInit", () => {
    if (typeof window < "u" && // eslint-disable-line
    (typeof e.params.controller.control == "string" || e.params.controller.control instanceof HTMLElement)) {
      const l = document.querySelector(e.params.controller.control);
      if (l && l.swiper)
        e.controller.control = l.swiper;
      else if (l) {
        const c = (u) => {
          e.controller.control = u.detail[0], e.update(), l.removeEventListener("init", c);
        };
        l.addEventListener("init", c);
      }
      return;
    }
    e.controller.control = e.params.controller.control;
  }), s("update", () => {
    o();
  }), s("resize", () => {
    o();
  }), s("observerUpdate", () => {
    o();
  }), s("setTranslate", (l, c, u) => {
    e.controller.control && e.controller.setTranslate(c, u);
  }), s("setTransition", (l, c, u) => {
    e.controller.control && e.controller.setTransition(c, u);
  }), Object.assign(e.controller, {
    setTranslate: a,
    setTransition: r
  });
}
function A11y({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    a11y: {
      enabled: !0,
      notificationClass: "swiper-notification",
      prevSlideMessage: "Previous slide",
      nextSlideMessage: "Next slide",
      firstSlideMessage: "This is the first slide",
      lastSlideMessage: "This is the last slide",
      paginationBulletMessage: "Go to slide {{index}}",
      slideLabelMessage: "{{index}} / {{slidesLength}}",
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: "group",
      id: null
    }
  }), e.a11y = {
    clicked: !1
  };
  let i = null;
  function n(y) {
    const T = i;
    T.length !== 0 && (T.innerHTML = "", T.innerHTML = y);
  }
  const a = (y) => (Array.isArray(y) || (y = [y].filter((T) => !!T)), y);
  function r(y = 16) {
    const T = () => Math.round(16 * Math.random()).toString(16);
    return "x".repeat(y).replace(/x/g, T);
  }
  function o(y) {
    y = a(y), y.forEach((T) => {
      T.setAttribute("tabIndex", "0");
    });
  }
  function l(y) {
    y = a(y), y.forEach((T) => {
      T.setAttribute("tabIndex", "-1");
    });
  }
  function c(y, T) {
    y = a(y), y.forEach(($) => {
      $.setAttribute("role", T);
    });
  }
  function u(y, T) {
    y = a(y), y.forEach(($) => {
      $.setAttribute("aria-roledescription", T);
    });
  }
  function d(y, T) {
    y = a(y), y.forEach(($) => {
      $.setAttribute("aria-controls", T);
    });
  }
  function h(y, T) {
    y = a(y), y.forEach(($) => {
      $.setAttribute("aria-label", T);
    });
  }
  function g(y, T) {
    y = a(y), y.forEach(($) => {
      $.setAttribute("id", T);
    });
  }
  function p(y, T) {
    y = a(y), y.forEach(($) => {
      $.setAttribute("aria-live", T);
    });
  }
  function m(y) {
    y = a(y), y.forEach((T) => {
      T.setAttribute("aria-disabled", !0);
    });
  }
  function v(y) {
    y = a(y), y.forEach((T) => {
      T.setAttribute("aria-disabled", !1);
    });
  }
  function f(y) {
    if (y.keyCode !== 13 && y.keyCode !== 32)
      return;
    const T = e.params.a11y, $ = y.target;
    e.pagination && e.pagination.el && ($ === e.pagination.el || e.pagination.el.contains(y.target)) && !y.target.matches(classesToSelector(e.params.pagination.bulletClass)) || (e.navigation && e.navigation.nextEl && $ === e.navigation.nextEl && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? n(T.lastSlideMessage) : n(T.nextSlideMessage)), e.navigation && e.navigation.prevEl && $ === e.navigation.prevEl && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? n(T.firstSlideMessage) : n(T.prevSlideMessage)), e.pagination && $.matches(classesToSelector(e.params.pagination.bulletClass)) && $.click());
  }
  function b() {
    if (e.params.loop || e.params.rewind || !e.navigation)
      return;
    const {
      nextEl: y,
      prevEl: T
    } = e.navigation;
    T && (e.isBeginning ? (m(T), l(T)) : (v(T), o(T))), y && (e.isEnd ? (m(y), l(y)) : (v(y), o(y)));
  }
  function E() {
    return e.pagination && e.pagination.bullets && e.pagination.bullets.length;
  }
  function A() {
    return E() && e.params.pagination.clickable;
  }
  function C() {
    const y = e.params.a11y;
    E() && e.pagination.bullets.forEach((T) => {
      e.params.pagination.clickable && (o(T), e.params.pagination.renderBullet || (c(T, "button"), h(T, y.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(T) + 1)))), T.matches(`.${e.params.pagination.bulletActiveClass}`) ? T.setAttribute("aria-current", "true") : T.removeAttribute("aria-current");
    });
  }
  const w = (y, T, $) => {
    o(y), y.tagName !== "BUTTON" && (c(y, "button"), y.addEventListener("keydown", f)), h(y, $), d(y, T);
  }, M = () => {
    e.a11y.clicked = !0;
  }, k = () => {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        e.destroyed || (e.a11y.clicked = !1);
      });
    });
  }, O = (y) => {
    if (e.a11y.clicked)
      return;
    const T = y.target.closest(`.${e.params.slideClass}, swiper-slide`);
    if (!T || !e.slides.includes(T))
      return;
    const $ = e.slides.indexOf(T) === e.activeIndex, _ = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(T);
    $ || _ || y.sourceCapabilities && y.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, e.slideTo(e.slides.indexOf(T), 0));
  }, z = () => {
    const y = e.params.a11y;
    y.itemRoleDescriptionMessage && u(e.slides, y.itemRoleDescriptionMessage), y.slideRole && c(e.slides, y.slideRole);
    const T = e.slides.length;
    y.slideLabelMessage && e.slides.forEach(($, _) => {
      const L = e.params.loop ? parseInt($.getAttribute("data-swiper-slide-index"), 10) : _, P = y.slideLabelMessage.replace(/\{\{index\}\}/, L + 1).replace(/\{\{slidesLength\}\}/, T);
      h($, P);
    });
  }, S = () => {
    const y = e.params.a11y;
    e.el.append(i);
    const T = e.el;
    y.containerRoleDescriptionMessage && u(T, y.containerRoleDescriptionMessage), y.containerMessage && h(T, y.containerMessage);
    const $ = e.wrapperEl, _ = y.id || $.getAttribute("id") || `swiper-wrapper-${r(16)}`, L = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite";
    g($, _), p($, L), z();
    let {
      nextEl: P,
      prevEl: D
    } = e.navigation ? e.navigation : {};
    P = a(P), D = a(D), P && P.forEach((R) => w(R, _, y.nextSlideMessage)), D && D.forEach((R) => w(R, _, y.prevSlideMessage)), A() && (Array.isArray(e.pagination.el) ? e.pagination.el : [e.pagination.el]).forEach((N) => {
      N.addEventListener("keydown", f);
    }), e.el.addEventListener("focus", O, !0), e.el.addEventListener("pointerdown", M, !0), e.el.addEventListener("pointerup", k, !0);
  };
  function x() {
    i && i.length > 0 && i.remove();
    let {
      nextEl: y,
      prevEl: T
    } = e.navigation ? e.navigation : {};
    y = a(y), T = a(T), y && y.forEach(($) => $.removeEventListener("keydown", f)), T && T.forEach(($) => $.removeEventListener("keydown", f)), A() && (Array.isArray(e.pagination.el) ? e.pagination.el : [e.pagination.el]).forEach((_) => {
      _.removeEventListener("keydown", f);
    }), e.el.removeEventListener("focus", O, !0), e.el.removeEventListener("pointerdown", M, !0), e.el.removeEventListener("pointerup", k, !0);
  }
  s("beforeInit", () => {
    i = createElement("span", e.params.a11y.notificationClass), i.setAttribute("aria-live", "assertive"), i.setAttribute("aria-atomic", "true"), e.isElement && i.setAttribute("slot", "container-end");
  }), s("afterInit", () => {
    e.params.a11y.enabled && S();
  }), s("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
    e.params.a11y.enabled && z();
  }), s("fromEdge toEdge afterInit lock unlock", () => {
    e.params.a11y.enabled && b();
  }), s("paginationUpdate", () => {
    e.params.a11y.enabled && C();
  }), s("destroy", () => {
    e.params.a11y.enabled && x();
  });
}
function History({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    history: {
      enabled: !1,
      root: "",
      replaceState: !1,
      key: "slides",
      keepQuery: !1
    }
  });
  let i = !1, n = {};
  const a = (h) => h.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), r = (h) => {
    const g = getWindow();
    let p;
    h ? p = new URL(h) : p = g.location;
    const m = p.pathname.slice(1).split("/").filter((E) => E !== ""), v = m.length, f = m[v - 2], b = m[v - 1];
    return {
      key: f,
      value: b
    };
  }, o = (h, g) => {
    const p = getWindow();
    if (!i || !e.params.history.enabled)
      return;
    let m;
    e.params.url ? m = new URL(e.params.url) : m = p.location;
    const v = e.slides[g];
    let f = a(v.getAttribute("data-history"));
    if (e.params.history.root.length > 0) {
      let E = e.params.history.root;
      E[E.length - 1] === "/" && (E = E.slice(0, E.length - 1)), f = `${E}/${h ? `${h}/` : ""}${f}`;
    } else
      m.pathname.includes(h) || (f = `${h ? `${h}/` : ""}${f}`);
    e.params.history.keepQuery && (f += m.search);
    const b = p.history.state;
    b && b.value === f || (e.params.history.replaceState ? p.history.replaceState({
      value: f
    }, null, f) : p.history.pushState({
      value: f
    }, null, f));
  }, l = (h, g, p) => {
    if (g)
      for (let m = 0, v = e.slides.length; m < v; m += 1) {
        const f = e.slides[m];
        if (a(f.getAttribute("data-history")) === g) {
          const E = elementIndex(f);
          e.slideTo(E, h, p);
        }
      }
    else
      e.slideTo(0, h, p);
  }, c = () => {
    n = r(e.params.url), l(e.params.speed, n.value, !1);
  }, u = () => {
    const h = getWindow();
    if (e.params.history) {
      if (!h.history || !h.history.pushState) {
        e.params.history.enabled = !1, e.params.hashNavigation.enabled = !0;
        return;
      }
      if (i = !0, n = r(e.params.url), !n.key && !n.value) {
        e.params.history.replaceState || h.addEventListener("popstate", c);
        return;
      }
      l(0, n.value, e.params.runCallbacksOnInit), e.params.history.replaceState || h.addEventListener("popstate", c);
    }
  }, d = () => {
    const h = getWindow();
    e.params.history.replaceState || h.removeEventListener("popstate", c);
  };
  s("init", () => {
    e.params.history.enabled && u();
  }), s("destroy", () => {
    e.params.history.enabled && d();
  }), s("transitionEnd _freeModeNoMomentumRelease", () => {
    i && o(e.params.history.key, e.activeIndex);
  }), s("slideChange", () => {
    i && e.params.cssMode && o(e.params.history.key, e.activeIndex);
  });
}
function HashNavigation({
  swiper: e,
  extendParams: t,
  emit: s,
  on: i
}) {
  let n = !1;
  const a = getDocument(), r = getWindow();
  t({
    hashNavigation: {
      enabled: !1,
      replaceState: !1,
      watchState: !1
    }
  });
  const o = () => {
    s("hashChange");
    const d = a.location.hash.replace("#", ""), h = e.slides[e.activeIndex].getAttribute("data-hash");
    if (d !== h) {
      const g = elementIndex(elementChildren(e.slidesEl, `.${e.params.slideClass}[data-hash="${d}"], swiper-slide[data-hash="${d}"]`)[0]);
      if (typeof g > "u")
        return;
      e.slideTo(g);
    }
  }, l = () => {
    if (!(!n || !e.params.hashNavigation.enabled))
      if (e.params.hashNavigation.replaceState && r.history && r.history.replaceState)
        r.history.replaceState(null, null, `#${e.slides[e.activeIndex].getAttribute("data-hash")}` || ""), s("hashSet");
      else {
        const d = e.slides[e.activeIndex], h = d.getAttribute("data-hash") || d.getAttribute("data-history");
        a.location.hash = h || "", s("hashSet");
      }
  }, c = () => {
    if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled)
      return;
    n = !0;
    const d = a.location.hash.replace("#", "");
    if (d)
      for (let g = 0, p = e.slides.length; g < p; g += 1) {
        const m = e.slides[g];
        if ((m.getAttribute("data-hash") || m.getAttribute("data-history")) === d) {
          const f = elementIndex(m);
          e.slideTo(f, 0, e.params.runCallbacksOnInit, !0);
        }
      }
    e.params.hashNavigation.watchState && r.addEventListener("hashchange", o);
  }, u = () => {
    e.params.hashNavigation.watchState && r.removeEventListener("hashchange", o);
  };
  i("init", () => {
    e.params.hashNavigation.enabled && c();
  }), i("destroy", () => {
    e.params.hashNavigation.enabled && u();
  }), i("transitionEnd _freeModeNoMomentumRelease", () => {
    n && l();
  }), i("slideChange", () => {
    n && e.params.cssMode && l();
  });
}
function Autoplay({
  swiper: e,
  extendParams: t,
  on: s,
  emit: i,
  params: n
}) {
  e.autoplay = {
    running: !1,
    paused: !1,
    timeLeft: 0
  }, t({
    autoplay: {
      enabled: !1,
      delay: 3e3,
      waitForTransition: !0,
      disableOnInteraction: !0,
      stopOnLastSlide: !1,
      reverseDirection: !1,
      pauseOnMouseEnter: !1
    }
  });
  let a, r, o = n && n.autoplay ? n.autoplay.delay : 3e3, l = n && n.autoplay ? n.autoplay.delay : 3e3, c, u = new Date().getTime, d, h, g, p, m, v;
  function f(_) {
    !e || e.destroyed || !e.wrapperEl || _.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", f), k());
  }
  const b = () => {
    if (e.destroyed || !e.autoplay.running)
      return;
    e.autoplay.paused ? d = !0 : d && (l = c, d = !1);
    const _ = e.autoplay.paused ? c : u + l - new Date().getTime();
    e.autoplay.timeLeft = _, i("autoplayTimeLeft", _, _ / o), r = requestAnimationFrame(() => {
      b();
    });
  }, E = () => {
    let _;
    return e.virtual && e.params.virtual.enabled ? _ = e.slides.filter((P) => P.classList.contains("swiper-slide-active"))[0] : _ = e.slides[e.activeIndex], _ ? parseInt(_.getAttribute("data-swiper-autoplay"), 10) : void 0;
  }, A = (_) => {
    if (e.destroyed || !e.autoplay.running)
      return;
    cancelAnimationFrame(r), b();
    let L = typeof _ > "u" ? e.params.autoplay.delay : _;
    o = e.params.autoplay.delay, l = e.params.autoplay.delay;
    const P = E();
    !Number.isNaN(P) && P > 0 && typeof _ > "u" && (L = P, o = P, l = P), c = L;
    const D = e.params.speed, R = () => {
      !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(D, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, D, !0, !0), i("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(D, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, D, !0, !0), i("autoplay")), e.params.cssMode && (u = new Date().getTime(), requestAnimationFrame(() => {
        A();
      })));
    };
    return L > 0 ? (clearTimeout(a), a = setTimeout(() => {
      R();
    }, L)) : requestAnimationFrame(() => {
      R();
    }), L;
  }, C = () => {
    e.autoplay.running = !0, A(), i("autoplayStart");
  }, w = () => {
    e.autoplay.running = !1, clearTimeout(a), cancelAnimationFrame(r), i("autoplayStop");
  }, M = (_, L) => {
    if (e.destroyed || !e.autoplay.running)
      return;
    clearTimeout(a), _ || (v = !0);
    const P = () => {
      i("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", f) : k();
    };
    if (e.autoplay.paused = !0, L) {
      m && (c = e.params.autoplay.delay), m = !1, P();
      return;
    }
    c = (c || e.params.autoplay.delay) - (new Date().getTime() - u), !(e.isEnd && c < 0 && !e.params.loop) && (c < 0 && (c = 0), P());
  }, k = () => {
    e.isEnd && c < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (u = new Date().getTime(), v ? (v = !1, A(c)) : A(), e.autoplay.paused = !1, i("autoplayResume"));
  }, O = () => {
    if (e.destroyed || !e.autoplay.running)
      return;
    const _ = getDocument();
    _.visibilityState === "hidden" && (v = !0, M(!0)), _.visibilityState === "visible" && k();
  }, z = (_) => {
    _.pointerType === "mouse" && (v = !0, M(!0));
  }, S = (_) => {
    _.pointerType === "mouse" && e.autoplay.paused && k();
  }, x = () => {
    e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", z), e.el.addEventListener("pointerleave", S));
  }, y = () => {
    e.el.removeEventListener("pointerenter", z), e.el.removeEventListener("pointerleave", S);
  }, T = () => {
    getDocument().addEventListener("visibilitychange", O);
  }, $ = () => {
    getDocument().removeEventListener("visibilitychange", O);
  };
  s("init", () => {
    e.params.autoplay.enabled && (x(), T(), u = new Date().getTime(), C());
  }), s("destroy", () => {
    y(), $(), e.autoplay.running && w();
  }), s("beforeTransitionStart", (_, L, P) => {
    e.destroyed || !e.autoplay.running || (P || !e.params.autoplay.disableOnInteraction ? M(!0, !0) : w());
  }), s("sliderFirstMove", () => {
    if (!(e.destroyed || !e.autoplay.running)) {
      if (e.params.autoplay.disableOnInteraction) {
        w();
        return;
      }
      h = !0, g = !1, v = !1, p = setTimeout(() => {
        v = !0, g = !0, M(!0);
      }, 200);
    }
  }), s("touchEnd", () => {
    if (!(e.destroyed || !e.autoplay.running || !h)) {
      if (clearTimeout(p), clearTimeout(a), e.params.autoplay.disableOnInteraction) {
        g = !1, h = !1;
        return;
      }
      g && e.params.cssMode && k(), g = !1, h = !1;
    }
  }), s("slideChange", () => {
    e.destroyed || !e.autoplay.running || (m = !0);
  }), Object.assign(e.autoplay, {
    start: C,
    stop: w,
    pause: M,
    resume: k
  });
}
function Thumb({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: !0,
      autoScrollOffset: 0,
      slideThumbActiveClass: "swiper-slide-thumb-active",
      thumbsContainerClass: "swiper-thumbs"
    }
  });
  let i = !1, n = !1;
  e.thumbs = {
    swiper: null
  };
  function a() {
    const l = e.thumbs.swiper;
    if (!l || l.destroyed)
      return;
    const c = l.clickedIndex, u = l.clickedSlide;
    if (u && u.classList.contains(e.params.thumbs.slideThumbActiveClass) || typeof c > "u" || c === null)
      return;
    let d;
    l.params.loop ? d = parseInt(l.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : d = c, e.params.loop ? e.slideToLoop(d) : e.slideTo(d);
  }
  function r() {
    const {
      thumbs: l
    } = e.params;
    if (i)
      return !1;
    i = !0;
    const c = e.constructor;
    if (l.swiper instanceof c)
      e.thumbs.swiper = l.swiper, Object.assign(e.thumbs.swiper.originalParams, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), Object.assign(e.thumbs.swiper.params, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), e.thumbs.swiper.update();
    else if (isObject$1(l.swiper)) {
      const u = Object.assign({}, l.swiper);
      Object.assign(u, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), e.thumbs.swiper = new c(u), n = !0;
    }
    return e.thumbs.swiper.el.classList.add(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", a), !0;
  }
  function o(l) {
    const c = e.thumbs.swiper;
    if (!c || c.destroyed)
      return;
    const u = c.params.slidesPerView === "auto" ? c.slidesPerViewDynamic() : c.params.slidesPerView;
    let d = 1;
    const h = e.params.thumbs.slideThumbActiveClass;
    if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (d = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (d = 1), d = Math.floor(d), c.slides.forEach((m) => m.classList.remove(h)), c.params.loop || c.params.virtual && c.params.virtual.enabled)
      for (let m = 0; m < d; m += 1)
        elementChildren(c.slidesEl, `[data-swiper-slide-index="${e.realIndex + m}"]`).forEach((v) => {
          v.classList.add(h);
        });
    else
      for (let m = 0; m < d; m += 1)
        c.slides[e.realIndex + m] && c.slides[e.realIndex + m].classList.add(h);
    const g = e.params.thumbs.autoScrollOffset, p = g && !c.params.loop;
    if (e.realIndex !== c.realIndex || p) {
      const m = c.activeIndex;
      let v, f;
      if (c.params.loop) {
        const b = c.slides.filter((E) => E.getAttribute("data-swiper-slide-index") === `${e.realIndex}`)[0];
        v = c.slides.indexOf(b), f = e.activeIndex > e.previousIndex ? "next" : "prev";
      } else
        v = e.realIndex, f = v > e.previousIndex ? "next" : "prev";
      p && (v += f === "next" ? g : -1 * g), c.visibleSlidesIndexes && c.visibleSlidesIndexes.indexOf(v) < 0 && (c.params.centeredSlides ? v > m ? v = v - Math.floor(u / 2) + 1 : v = v + Math.floor(u / 2) - 1 : v > m && c.params.slidesPerGroup, c.slideTo(v, l ? 0 : void 0));
    }
  }
  s("beforeInit", () => {
    const {
      thumbs: l
    } = e.params;
    if (!(!l || !l.swiper))
      if (typeof l.swiper == "string" || l.swiper instanceof HTMLElement) {
        const c = getDocument(), u = () => {
          const h = typeof l.swiper == "string" ? c.querySelector(l.swiper) : l.swiper;
          if (h && h.swiper)
            l.swiper = h.swiper, r(), o(!0);
          else if (h) {
            const g = (p) => {
              l.swiper = p.detail[0], h.removeEventListener("init", g), r(), o(!0), l.swiper.update(), e.update();
            };
            h.addEventListener("init", g);
          }
          return h;
        }, d = () => {
          if (e.destroyed)
            return;
          u() || requestAnimationFrame(d);
        };
        requestAnimationFrame(d);
      } else
        r(), o(!0);
  }), s("slideChange update resize observerUpdate", () => {
    o();
  }), s("setTransition", (l, c) => {
    const u = e.thumbs.swiper;
    !u || u.destroyed || u.setTransition(c);
  }), s("beforeDestroy", () => {
    const l = e.thumbs.swiper;
    !l || l.destroyed || n && l.destroy();
  }), Object.assign(e.thumbs, {
    init: r,
    update: o
  });
}
function freeMode({
  swiper: e,
  extendParams: t,
  emit: s,
  once: i
}) {
  t({
    freeMode: {
      enabled: !1,
      momentum: !0,
      momentumRatio: 1,
      momentumBounce: !0,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: !1,
      minimumVelocity: 0.02
    }
  });
  function n() {
    const o = e.getTranslate();
    e.setTranslate(o), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({
      currentPos: e.rtl ? e.translate : -e.translate
    });
  }
  function a() {
    const {
      touchEventsData: o,
      touches: l
    } = e;
    o.velocities.length === 0 && o.velocities.push({
      position: l[e.isHorizontal() ? "startX" : "startY"],
      time: o.touchStartTime
    }), o.velocities.push({
      position: l[e.isHorizontal() ? "currentX" : "currentY"],
      time: now()
    });
  }
  function r({
    currentPos: o
  }) {
    const {
      params: l,
      wrapperEl: c,
      rtlTranslate: u,
      snapGrid: d,
      touchEventsData: h
    } = e, p = now() - h.touchStartTime;
    if (o < -e.minTranslate()) {
      e.slideTo(e.activeIndex);
      return;
    }
    if (o > -e.maxTranslate()) {
      e.slides.length < d.length ? e.slideTo(d.length - 1) : e.slideTo(e.slides.length - 1);
      return;
    }
    if (l.freeMode.momentum) {
      if (h.velocities.length > 1) {
        const w = h.velocities.pop(), M = h.velocities.pop(), k = w.position - M.position, O = w.time - M.time;
        e.velocity = k / O, e.velocity /= 2, Math.abs(e.velocity) < l.freeMode.minimumVelocity && (e.velocity = 0), (O > 150 || now() - w.time > 300) && (e.velocity = 0);
      } else
        e.velocity = 0;
      e.velocity *= l.freeMode.momentumVelocityRatio, h.velocities.length = 0;
      let m = 1e3 * l.freeMode.momentumRatio;
      const v = e.velocity * m;
      let f = e.translate + v;
      u && (f = -f);
      let b = !1, E;
      const A = Math.abs(e.velocity) * 20 * l.freeMode.momentumBounceRatio;
      let C;
      if (f < e.maxTranslate())
        l.freeMode.momentumBounce ? (f + e.maxTranslate() < -A && (f = e.maxTranslate() - A), E = e.maxTranslate(), b = !0, h.allowMomentumBounce = !0) : f = e.maxTranslate(), l.loop && l.centeredSlides && (C = !0);
      else if (f > e.minTranslate())
        l.freeMode.momentumBounce ? (f - e.minTranslate() > A && (f = e.minTranslate() + A), E = e.minTranslate(), b = !0, h.allowMomentumBounce = !0) : f = e.minTranslate(), l.loop && l.centeredSlides && (C = !0);
      else if (l.freeMode.sticky) {
        let w;
        for (let M = 0; M < d.length; M += 1)
          if (d[M] > -f) {
            w = M;
            break;
          }
        Math.abs(d[w] - f) < Math.abs(d[w - 1] - f) || e.swipeDirection === "next" ? f = d[w] : f = d[w - 1], f = -f;
      }
      if (C && i("transitionEnd", () => {
        e.loopFix();
      }), e.velocity !== 0) {
        if (u ? m = Math.abs((-f - e.translate) / e.velocity) : m = Math.abs((f - e.translate) / e.velocity), l.freeMode.sticky) {
          const w = Math.abs((u ? -f : f) - e.translate), M = e.slidesSizesGrid[e.activeIndex];
          w < M ? m = l.speed : w < 2 * M ? m = l.speed * 1.5 : m = l.speed * 2.5;
        }
      } else if (l.freeMode.sticky) {
        e.slideToClosest();
        return;
      }
      l.freeMode.momentumBounce && b ? (e.updateProgress(E), e.setTransition(m), e.setTranslate(f), e.transitionStart(!0, e.swipeDirection), e.animating = !0, elementTransitionEnd(c, () => {
        !e || e.destroyed || !h.allowMomentumBounce || (s("momentumBounce"), e.setTransition(l.speed), setTimeout(() => {
          e.setTranslate(E), elementTransitionEnd(c, () => {
            !e || e.destroyed || e.transitionEnd();
          });
        }, 0));
      })) : e.velocity ? (s("_freeModeNoMomentumRelease"), e.updateProgress(f), e.setTransition(m), e.setTranslate(f), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, elementTransitionEnd(c, () => {
        !e || e.destroyed || e.transitionEnd();
      }))) : e.updateProgress(f), e.updateActiveIndex(), e.updateSlidesClasses();
    } else if (l.freeMode.sticky) {
      e.slideToClosest();
      return;
    } else
      l.freeMode && s("_freeModeNoMomentumRelease");
    (!l.freeMode.momentum || p >= l.longSwipesMs) && (e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses());
  }
  Object.assign(e, {
    freeMode: {
      onTouchStart: n,
      onTouchMove: a,
      onTouchEnd: r
    }
  });
}
function Grid({
  swiper: e,
  extendParams: t
}) {
  t({
    grid: {
      rows: 1,
      fill: "column"
    }
  });
  let s, i, n;
  const a = (l) => {
    const {
      slidesPerView: c
    } = e.params, {
      rows: u,
      fill: d
    } = e.params.grid;
    i = s / u, n = Math.floor(l / u), Math.floor(l / u) === l / u ? s = l : s = Math.ceil(l / u) * u, c !== "auto" && d === "row" && (s = Math.max(s, c * u));
  }, r = (l, c, u, d) => {
    const {
      slidesPerGroup: h,
      spaceBetween: g
    } = e.params, {
      rows: p,
      fill: m
    } = e.params.grid;
    let v, f, b;
    if (m === "row" && h > 1) {
      const E = Math.floor(l / (h * p)), A = l - p * h * E, C = E === 0 ? h : Math.min(Math.ceil((u - E * p * h) / p), h);
      b = Math.floor(A / C), f = A - b * C + E * h, v = f + b * s / p, c.style.order = v;
    } else
      m === "column" ? (f = Math.floor(l / p), b = l - f * p, (f > n || f === n && b === p - 1) && (b += 1, b >= p && (b = 0, f += 1))) : (b = Math.floor(l / i), f = l - b * i);
    c.style[d("margin-top")] = b !== 0 ? g && `${g}px` : "";
  }, o = (l, c, u) => {
    const {
      spaceBetween: d,
      centeredSlides: h,
      roundLengths: g
    } = e.params, {
      rows: p
    } = e.params.grid;
    if (e.virtualSize = (l + d) * s, e.virtualSize = Math.ceil(e.virtualSize / p) - d, e.wrapperEl.style[u("width")] = `${e.virtualSize + d}px`, h) {
      const m = [];
      for (let v = 0; v < c.length; v += 1) {
        let f = c[v];
        g && (f = Math.floor(f)), c[v] < e.virtualSize + c[0] && m.push(f);
      }
      c.splice(0, c.length), c.push(...m);
    }
  };
  e.grid = {
    initSlides: a,
    updateSlide: r,
    updateWrapperSize: o
  };
}
function appendSlide(e) {
  const t = this, {
    params: s,
    slidesEl: i
  } = t;
  s.loop && t.loopDestroy();
  const n = (a) => {
    if (typeof a == "string") {
      const r = document.createElement("div");
      r.innerHTML = a, i.append(r.children[0]), r.innerHTML = "";
    } else
      i.append(a);
  };
  if (typeof e == "object" && "length" in e)
    for (let a = 0; a < e.length; a += 1)
      e[a] && n(e[a]);
  else
    n(e);
  t.recalcSlides(), s.loop && t.loopCreate(), (!s.observer || t.isElement) && t.update();
}
function prependSlide(e) {
  const t = this, {
    params: s,
    activeIndex: i,
    slidesEl: n
  } = t;
  s.loop && t.loopDestroy();
  let a = i + 1;
  const r = (o) => {
    if (typeof o == "string") {
      const l = document.createElement("div");
      l.innerHTML = o, n.prepend(l.children[0]), l.innerHTML = "";
    } else
      n.prepend(o);
  };
  if (typeof e == "object" && "length" in e) {
    for (let o = 0; o < e.length; o += 1)
      e[o] && r(e[o]);
    a = i + e.length;
  } else
    r(e);
  t.recalcSlides(), s.loop && t.loopCreate(), (!s.observer || t.isElement) && t.update(), t.slideTo(a, 0, !1);
}
function addSlide(e, t) {
  const s = this, {
    params: i,
    activeIndex: n,
    slidesEl: a
  } = s;
  let r = n;
  i.loop && (r -= s.loopedSlides, s.loopDestroy(), s.recalcSlides());
  const o = s.slides.length;
  if (e <= 0) {
    s.prependSlide(t);
    return;
  }
  if (e >= o) {
    s.appendSlide(t);
    return;
  }
  let l = r > e ? r + 1 : r;
  const c = [];
  for (let u = o - 1; u >= e; u -= 1) {
    const d = s.slides[u];
    d.remove(), c.unshift(d);
  }
  if (typeof t == "object" && "length" in t) {
    for (let u = 0; u < t.length; u += 1)
      t[u] && a.append(t[u]);
    l = r > e ? r + t.length : r;
  } else
    a.append(t);
  for (let u = 0; u < c.length; u += 1)
    a.append(c[u]);
  s.recalcSlides(), i.loop && s.loopCreate(), (!i.observer || s.isElement) && s.update(), i.loop ? s.slideTo(l + s.loopedSlides, 0, !1) : s.slideTo(l, 0, !1);
}
function removeSlide(e) {
  const t = this, {
    params: s,
    activeIndex: i
  } = t;
  let n = i;
  s.loop && (n -= t.loopedSlides, t.loopDestroy());
  let a = n, r;
  if (typeof e == "object" && "length" in e) {
    for (let o = 0; o < e.length; o += 1)
      r = e[o], t.slides[r] && t.slides[r].remove(), r < a && (a -= 1);
    a = Math.max(a, 0);
  } else
    r = e, t.slides[r] && t.slides[r].remove(), r < a && (a -= 1), a = Math.max(a, 0);
  t.recalcSlides(), s.loop && t.loopCreate(), (!s.observer || t.isElement) && t.update(), s.loop ? t.slideTo(a + t.loopedSlides, 0, !1) : t.slideTo(a, 0, !1);
}
function removeAllSlides() {
  const e = this, t = [];
  for (let s = 0; s < e.slides.length; s += 1)
    t.push(s);
  e.removeSlide(t);
}
function Manipulation({
  swiper: e
}) {
  Object.assign(e, {
    appendSlide: appendSlide.bind(e),
    prependSlide: prependSlide.bind(e),
    addSlide: addSlide.bind(e),
    removeSlide: removeSlide.bind(e),
    removeAllSlides: removeAllSlides.bind(e)
  });
}
function effectInit(e) {
  const {
    effect: t,
    swiper: s,
    on: i,
    setTranslate: n,
    setTransition: a,
    overwriteParams: r,
    perspective: o,
    recreateShadows: l,
    getEffectParams: c
  } = e;
  i("beforeInit", () => {
    if (s.params.effect !== t)
      return;
    s.classNames.push(`${s.params.containerModifierClass}${t}`), o && o() && s.classNames.push(`${s.params.containerModifierClass}3d`);
    const d = r ? r() : {};
    Object.assign(s.params, d), Object.assign(s.originalParams, d);
  }), i("setTranslate", () => {
    s.params.effect === t && n();
  }), i("setTransition", (d, h) => {
    s.params.effect === t && a(h);
  }), i("transitionEnd", () => {
    if (s.params.effect === t && l) {
      if (!c || !c().slideShadows)
        return;
      s.slides.forEach((d) => {
        d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((h) => h.remove());
      }), l();
    }
  });
  let u;
  i("virtualUpdate", () => {
    s.params.effect === t && (s.slides.length || (u = !0), requestAnimationFrame(() => {
      u && s.slides && s.slides.length && (n(), u = !1);
    }));
  });
}
function effectTarget(e, t) {
  const s = getSlideTransformEl(t);
  return s !== t && (s.style.backfaceVisibility = "hidden", s.style["-webkit-backface-visibility"] = "hidden"), s;
}
function effectVirtualTransitionEnd({
  swiper: e,
  duration: t,
  transformElements: s,
  allSlides: i
}) {
  const {
    activeIndex: n
  } = e, a = (r) => r.parentElement ? r.parentElement : e.slides.filter((l) => l.shadowEl && l.shadowEl === r.parentNode)[0];
  if (e.params.virtualTranslate && t !== 0) {
    let r = !1, o;
    i ? o = s : o = s.filter((l) => {
      const c = l.classList.contains("swiper-slide-transform") ? a(l) : l;
      return elementIndex(c) === n;
    }), o.forEach((l) => {
      elementTransitionEnd(l, () => {
        if (r || !e || e.destroyed)
          return;
        r = !0, e.animating = !1;
        const c = new window.CustomEvent("transitionend", {
          bubbles: !0,
          cancelable: !0
        });
        e.wrapperEl.dispatchEvent(c);
      });
    });
  }
}
function EffectFade({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    fadeEffect: {
      crossFade: !1
    }
  }), effectInit({
    effect: "fade",
    swiper: e,
    on: s,
    setTranslate: () => {
      const {
        slides: a
      } = e, r = e.params.fadeEffect;
      for (let o = 0; o < a.length; o += 1) {
        const l = e.slides[o];
        let u = -l.swiperSlideOffset;
        e.params.virtualTranslate || (u -= e.translate);
        let d = 0;
        e.isHorizontal() || (d = u, u = 0);
        const h = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(l.progress), 0) : 1 + Math.min(Math.max(l.progress, -1), 0), g = effectTarget(r, l);
        g.style.opacity = h, g.style.transform = `translate3d(${u}px, ${d}px, 0px)`;
      }
    },
    setTransition: (a) => {
      const r = e.slides.map((o) => getSlideTransformEl(o));
      r.forEach((o) => {
        o.style.transitionDuration = `${a}ms`;
      }), effectVirtualTransitionEnd({
        swiper: e,
        duration: a,
        transformElements: r,
        allSlides: !0
      });
    },
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: !0,
      spaceBetween: 0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
function EffectCube({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    cubeEffect: {
      slideShadows: !0,
      shadow: !0,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const i = (o, l, c) => {
    let u = c ? o.querySelector(".swiper-slide-shadow-left") : o.querySelector(".swiper-slide-shadow-top"), d = c ? o.querySelector(".swiper-slide-shadow-right") : o.querySelector(".swiper-slide-shadow-bottom");
    u || (u = createElement("div", `swiper-slide-shadow-${c ? "left" : "top"}`), o.append(u)), d || (d = createElement("div", `swiper-slide-shadow-${c ? "right" : "bottom"}`), o.append(d)), u && (u.style.opacity = Math.max(-l, 0)), d && (d.style.opacity = Math.max(l, 0));
  };
  effectInit({
    effect: "cube",
    swiper: e,
    on: s,
    setTranslate: () => {
      const {
        el: o,
        wrapperEl: l,
        slides: c,
        width: u,
        height: d,
        rtlTranslate: h,
        size: g,
        browser: p
      } = e, m = e.params.cubeEffect, v = e.isHorizontal(), f = e.virtual && e.params.virtual.enabled;
      let b = 0, E;
      m.shadow && (v ? (E = e.slidesEl.querySelector(".swiper-cube-shadow"), E || (E = createElement("div", "swiper-cube-shadow"), e.slidesEl.append(E)), E.style.height = `${u}px`) : (E = o.querySelector(".swiper-cube-shadow"), E || (E = createElement("div", "swiper-cube-shadow"), o.append(E))));
      for (let C = 0; C < c.length; C += 1) {
        const w = c[C];
        let M = C;
        f && (M = parseInt(w.getAttribute("data-swiper-slide-index"), 10));
        let k = M * 90, O = Math.floor(k / 360);
        h && (k = -k, O = Math.floor(-k / 360));
        const z = Math.max(Math.min(w.progress, 1), -1);
        let S = 0, x = 0, y = 0;
        M % 4 === 0 ? (S = -O * 4 * g, y = 0) : (M - 1) % 4 === 0 ? (S = 0, y = -O * 4 * g) : (M - 2) % 4 === 0 ? (S = g + O * 4 * g, y = g) : (M - 3) % 4 === 0 && (S = -g, y = 3 * g + g * 4 * O), h && (S = -S), v || (x = S, S = 0);
        const T = `rotateX(${v ? 0 : -k}deg) rotateY(${v ? k : 0}deg) translate3d(${S}px, ${x}px, ${y}px)`;
        z <= 1 && z > -1 && (b = M * 90 + z * 90, h && (b = -M * 90 - z * 90)), w.style.transform = T, m.slideShadows && i(w, z, v);
      }
      if (l.style.transformOrigin = `50% 50% -${g / 2}px`, l.style["-webkit-transform-origin"] = `50% 50% -${g / 2}px`, m.shadow)
        if (v)
          E.style.transform = `translate3d(0px, ${u / 2 + m.shadowOffset}px, ${-u / 2}px) rotateX(90deg) rotateZ(0deg) scale(${m.shadowScale})`;
        else {
          const C = Math.abs(b) - Math.floor(Math.abs(b) / 90) * 90, w = 1.5 - (Math.sin(C * 2 * Math.PI / 360) / 2 + Math.cos(C * 2 * Math.PI / 360) / 2), M = m.shadowScale, k = m.shadowScale / w, O = m.shadowOffset;
          E.style.transform = `scale3d(${M}, 1, ${k}) translate3d(0px, ${d / 2 + O}px, ${-d / 2 / k}px) rotateX(-90deg)`;
        }
      const A = (p.isSafari || p.isWebView) && p.needPerspectiveFix ? -g / 2 : 0;
      l.style.transform = `translate3d(0px,0,${A}px) rotateX(${e.isHorizontal() ? 0 : b}deg) rotateY(${e.isHorizontal() ? -b : 0}deg)`, l.style.setProperty("--swiper-cube-translate-z", `${A}px`);
    },
    setTransition: (o) => {
      const {
        el: l,
        slides: c
      } = e;
      if (c.forEach((u) => {
        u.style.transitionDuration = `${o}ms`, u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((d) => {
          d.style.transitionDuration = `${o}ms`;
        });
      }), e.params.cubeEffect.shadow && !e.isHorizontal()) {
        const u = l.querySelector(".swiper-cube-shadow");
        u && (u.style.transitionDuration = `${o}ms`);
      }
    },
    recreateShadows: () => {
      const o = e.isHorizontal();
      e.slides.forEach((l) => {
        const c = Math.max(Math.min(l.progress, 1), -1);
        i(l, c, o);
      });
    },
    getEffectParams: () => e.params.cubeEffect,
    perspective: () => !0,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: !0,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: !1,
      virtualTranslate: !0
    })
  });
}
function createShadow(e, t, s) {
  const i = `swiper-slide-shadow${s ? `-${s}` : ""}`, n = getSlideTransformEl(t);
  let a = n.querySelector(`.${i}`);
  return a || (a = createElement("div", `swiper-slide-shadow${s ? `-${s}` : ""}`), n.append(a)), a;
}
function EffectFlip({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    flipEffect: {
      slideShadows: !0,
      limitRotation: !0
    }
  });
  const i = (o, l, c) => {
    let u = e.isHorizontal() ? o.querySelector(".swiper-slide-shadow-left") : o.querySelector(".swiper-slide-shadow-top"), d = e.isHorizontal() ? o.querySelector(".swiper-slide-shadow-right") : o.querySelector(".swiper-slide-shadow-bottom");
    u || (u = createShadow(c, o, e.isHorizontal() ? "left" : "top")), d || (d = createShadow(c, o, e.isHorizontal() ? "right" : "bottom")), u && (u.style.opacity = Math.max(-l, 0)), d && (d.style.opacity = Math.max(l, 0));
  };
  effectInit({
    effect: "flip",
    swiper: e,
    on: s,
    setTranslate: () => {
      const {
        slides: o,
        rtlTranslate: l
      } = e, c = e.params.flipEffect;
      for (let u = 0; u < o.length; u += 1) {
        const d = o[u];
        let h = d.progress;
        e.params.flipEffect.limitRotation && (h = Math.max(Math.min(d.progress, 1), -1));
        const g = d.swiperSlideOffset;
        let m = -180 * h, v = 0, f = e.params.cssMode ? -g - e.translate : -g, b = 0;
        e.isHorizontal() ? l && (m = -m) : (b = f, f = 0, v = -m, m = 0), d.style.zIndex = -Math.abs(Math.round(h)) + o.length, c.slideShadows && i(d, h, c);
        const E = `translate3d(${f}px, ${b}px, 0px) rotateX(${v}deg) rotateY(${m}deg)`, A = effectTarget(c, d);
        A.style.transform = E;
      }
    },
    setTransition: (o) => {
      const l = e.slides.map((c) => getSlideTransformEl(c));
      l.forEach((c) => {
        c.style.transitionDuration = `${o}ms`, c.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((u) => {
          u.style.transitionDuration = `${o}ms`;
        });
      }), effectVirtualTransitionEnd({
        swiper: e,
        duration: o,
        transformElements: l
      });
    },
    recreateShadows: () => {
      const o = e.params.flipEffect;
      e.slides.forEach((l) => {
        let c = l.progress;
        e.params.flipEffect.limitRotation && (c = Math.max(Math.min(l.progress, 1), -1)), i(l, c, o);
      });
    },
    getEffectParams: () => e.params.flipEffect,
    perspective: () => !0,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: !0,
      spaceBetween: 0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
function EffectCoverflow({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: !0
    }
  }), effectInit({
    effect: "coverflow",
    swiper: e,
    on: s,
    setTranslate: () => {
      const {
        width: a,
        height: r,
        slides: o,
        slidesSizesGrid: l
      } = e, c = e.params.coverflowEffect, u = e.isHorizontal(), d = e.translate, h = u ? -d + a / 2 : -d + r / 2, g = u ? c.rotate : -c.rotate, p = c.depth;
      for (let m = 0, v = o.length; m < v; m += 1) {
        const f = o[m], b = l[m], E = f.swiperSlideOffset, A = (h - E - b / 2) / b, C = typeof c.modifier == "function" ? c.modifier(A) : A * c.modifier;
        let w = u ? g * C : 0, M = u ? 0 : g * C, k = -p * Math.abs(C), O = c.stretch;
        typeof O == "string" && O.indexOf("%") !== -1 && (O = parseFloat(c.stretch) / 100 * b);
        let z = u ? 0 : O * C, S = u ? O * C : 0, x = 1 - (1 - c.scale) * Math.abs(C);
        Math.abs(S) < 1e-3 && (S = 0), Math.abs(z) < 1e-3 && (z = 0), Math.abs(k) < 1e-3 && (k = 0), Math.abs(w) < 1e-3 && (w = 0), Math.abs(M) < 1e-3 && (M = 0), Math.abs(x) < 1e-3 && (x = 0);
        const y = `translate3d(${S}px,${z}px,${k}px)  rotateX(${M}deg) rotateY(${w}deg) scale(${x})`, T = effectTarget(c, f);
        if (T.style.transform = y, f.style.zIndex = -Math.abs(Math.round(C)) + 1, c.slideShadows) {
          let $ = u ? f.querySelector(".swiper-slide-shadow-left") : f.querySelector(".swiper-slide-shadow-top"), _ = u ? f.querySelector(".swiper-slide-shadow-right") : f.querySelector(".swiper-slide-shadow-bottom");
          $ || ($ = createShadow(c, f, u ? "left" : "top")), _ || (_ = createShadow(c, f, u ? "right" : "bottom")), $ && ($.style.opacity = C > 0 ? C : 0), _ && (_.style.opacity = -C > 0 ? -C : 0);
        }
      }
    },
    setTransition: (a) => {
      e.slides.map((o) => getSlideTransformEl(o)).forEach((o) => {
        o.style.transitionDuration = `${a}ms`, o.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((l) => {
          l.style.transitionDuration = `${a}ms`;
        });
      });
    },
    perspective: () => !0,
    overwriteParams: () => ({
      watchSlidesProgress: !0
    })
  });
}
function EffectCreative({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    creativeEffect: {
      limitProgress: 1,
      shadowPerProgress: !1,
      progressMultiplier: 1,
      perspective: !0,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const i = (r) => typeof r == "string" ? r : `${r}px`;
  effectInit({
    effect: "creative",
    swiper: e,
    on: s,
    setTranslate: () => {
      const {
        slides: r,
        wrapperEl: o,
        slidesSizesGrid: l
      } = e, c = e.params.creativeEffect, {
        progressMultiplier: u
      } = c, d = e.params.centeredSlides;
      if (d) {
        const h = l[0] / 2 - e.params.slidesOffsetBefore || 0;
        o.style.transform = `translateX(calc(50% - ${h}px))`;
      }
      for (let h = 0; h < r.length; h += 1) {
        const g = r[h], p = g.progress, m = Math.min(Math.max(g.progress, -c.limitProgress), c.limitProgress);
        let v = m;
        d || (v = Math.min(Math.max(g.originalProgress, -c.limitProgress), c.limitProgress));
        const f = g.swiperSlideOffset, b = [e.params.cssMode ? -f - e.translate : -f, 0, 0], E = [0, 0, 0];
        let A = !1;
        e.isHorizontal() || (b[1] = b[0], b[0] = 0);
        let C = {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          scale: 1,
          opacity: 1
        };
        m < 0 ? (C = c.next, A = !0) : m > 0 && (C = c.prev, A = !0), b.forEach((x, y) => {
          b[y] = `calc(${x}px + (${i(C.translate[y])} * ${Math.abs(m * u)}))`;
        }), E.forEach((x, y) => {
          E[y] = C.rotate[y] * Math.abs(m * u);
        }), g.style.zIndex = -Math.abs(Math.round(p)) + r.length;
        const w = b.join(", "), M = `rotateX(${E[0]}deg) rotateY(${E[1]}deg) rotateZ(${E[2]}deg)`, k = v < 0 ? `scale(${1 + (1 - C.scale) * v * u})` : `scale(${1 - (1 - C.scale) * v * u})`, O = v < 0 ? 1 + (1 - C.opacity) * v * u : 1 - (1 - C.opacity) * v * u, z = `translate3d(${w}) ${M} ${k}`;
        if (A && C.shadow || !A) {
          let x = g.querySelector(".swiper-slide-shadow");
          if (!x && C.shadow && (x = createShadow(c, g)), x) {
            const y = c.shadowPerProgress ? m * (1 / c.limitProgress) : m;
            x.style.opacity = Math.min(Math.max(Math.abs(y), 0), 1);
          }
        }
        const S = effectTarget(c, g);
        S.style.transform = z, S.style.opacity = O, C.origin && (S.style.transformOrigin = O);
      }
    },
    setTransition: (r) => {
      const o = e.slides.map((l) => getSlideTransformEl(l));
      o.forEach((l) => {
        l.style.transitionDuration = `${r}ms`, l.querySelectorAll(".swiper-slide-shadow").forEach((c) => {
          c.style.transitionDuration = `${r}ms`;
        });
      }), effectVirtualTransitionEnd({
        swiper: e,
        duration: r,
        transformElements: o,
        allSlides: !0
      });
    },
    perspective: () => e.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: !0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
function EffectCards({
  swiper: e,
  extendParams: t,
  on: s
}) {
  t({
    cardsEffect: {
      slideShadows: !0,
      rotate: !0,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  }), effectInit({
    effect: "cards",
    swiper: e,
    on: s,
    setTranslate: () => {
      const {
        slides: a,
        activeIndex: r
      } = e, o = e.params.cardsEffect, {
        startTranslate: l,
        isTouched: c
      } = e.touchEventsData, u = e.translate;
      for (let d = 0; d < a.length; d += 1) {
        const h = a[d], g = h.progress, p = Math.min(Math.max(g, -4), 4);
        let m = h.swiperSlideOffset;
        e.params.centeredSlides && !e.params.cssMode && (e.wrapperEl.style.transform = `translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (m -= a[0].swiperSlideOffset);
        let v = e.params.cssMode ? -m - e.translate : -m, f = 0;
        const b = -100 * Math.abs(p);
        let E = 1, A = -o.perSlideRotate * p, C = o.perSlideOffset - Math.abs(p) * 0.75;
        const w = e.virtual && e.params.virtual.enabled ? e.virtual.from + d : d, M = (w === r || w === r - 1) && p > 0 && p < 1 && (c || e.params.cssMode) && u < l, k = (w === r || w === r + 1) && p < 0 && p > -1 && (c || e.params.cssMode) && u > l;
        if (M || k) {
          const x = (1 - Math.abs((Math.abs(p) - 0.5) / 0.5)) ** 0.5;
          A += -28 * p * x, E += -0.5 * x, C += 96 * x, f = `${-25 * x * Math.abs(p)}%`;
        }
        if (p < 0 ? v = `calc(${v}px + (${C * Math.abs(p)}%))` : p > 0 ? v = `calc(${v}px + (-${C * Math.abs(p)}%))` : v = `${v}px`, !e.isHorizontal()) {
          const x = f;
          f = v, v = x;
        }
        const O = p < 0 ? `${1 + (1 - E) * p}` : `${1 - (1 - E) * p}`, z = `
        translate3d(${v}, ${f}, ${b}px)
        rotateZ(${o.rotate ? A : 0}deg)
        scale(${O})
      `;
        if (o.slideShadows) {
          let x = h.querySelector(".swiper-slide-shadow");
          x || (x = createShadow(o, h)), x && (x.style.opacity = Math.min(Math.max((Math.abs(p) - 0.5) / 0.5, 0), 1));
        }
        h.style.zIndex = -Math.abs(Math.round(g)) + a.length;
        const S = effectTarget(o, h);
        S.style.transform = z;
      }
    },
    setTransition: (a) => {
      const r = e.slides.map((o) => getSlideTransformEl(o));
      r.forEach((o) => {
        o.style.transitionDuration = `${a}ms`, o.querySelectorAll(".swiper-slide-shadow").forEach((l) => {
          l.style.transitionDuration = `${a}ms`;
        });
      }), effectVirtualTransitionEnd({
        swiper: e,
        duration: a,
        transformElements: r
      });
    },
    perspective: () => !0,
    overwriteParams: () => ({
      watchSlidesProgress: !0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
Swiper.use(modules);
const paramsList = [
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopedSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control",
  "injectStyles",
  "injectStylesUrls"
];
function isObject(e) {
  return typeof e == "object" && e !== null && e.constructor && Object.prototype.toString.call(e).slice(8, -1) === "Object";
}
function extend(e, t) {
  const s = ["__proto__", "constructor", "prototype"];
  Object.keys(t).filter((i) => s.indexOf(i) < 0).forEach((i) => {
    typeof e[i] > "u" ? e[i] = t[i] : isObject(t[i]) && isObject(e[i]) && Object.keys(t[i]).length > 0 ? t[i].__swiper__ ? e[i] = t[i] : extend(e[i], t[i]) : e[i] = t[i];
  });
}
function needsNavigation(e = {}) {
  return e.navigation && typeof e.navigation.nextEl > "u" && typeof e.navigation.prevEl > "u";
}
function needsPagination(e = {}) {
  return e.pagination && typeof e.pagination.el > "u";
}
function needsScrollbar(e = {}) {
  return e.scrollbar && typeof e.scrollbar.el > "u";
}
function attrToProp(e = "") {
  return e.replace(/-[a-z]/g, (t) => t.toUpperCase().replace("-", ""));
}
const formatValue = (e) => {
  if (parseFloat(e) === Number(e))
    return Number(e);
  if (e === "true" || e === "")
    return !0;
  if (e === "false")
    return !1;
  if (e === "null")
    return null;
  if (e !== "undefined")
    return e;
}, modulesParamsList = [
  "a11y",
  "autoplay",
  "controller",
  "cards-effect",
  "coverflow-effect",
  "creative-effect",
  "cube-effect",
  "fade-effect",
  "flip-effect",
  "free-mode",
  "grid",
  "hash-navigation",
  "history",
  "keyboard",
  "mousewheel",
  "navigation",
  "pagination",
  "parallax",
  "scrollbar",
  "thumbs",
  "virtual",
  "zoom"
];
function getParams(e) {
  const t = {}, s = {};
  extend(t, defaults);
  const i = paramsList.map((n) => n.replace(/_/, ""));
  return paramsList.forEach((n) => {
    n = n.replace("_", ""), typeof e[n] < "u" && (s[n] = e[n]);
  }), [...e.attributes].forEach((n) => {
    const a = modulesParamsList.filter(
      (r) => n.name.indexOf(`${r}-`) === 0
    )[0];
    if (a) {
      const r = attrToProp(a), o = attrToProp(n.name.split(`${a}-`)[1]);
      s[r] || (s[r] = {}), s[r] === !0 && (s[r] = { enabled: !0 }), s[r][o] = formatValue(n.value);
    } else {
      const r = attrToProp(n.name);
      if (!i.includes(r))
        return;
      const o = formatValue(n.value);
      s[r] && modulesParamsList.includes(n.name) ? (s[r].constructor !== Object && (s[r] = {}), s[r].enabled = o) : s[r] = o;
    }
  }), extend(t, s), t.navigation ? t.navigation = {
    prevEl: ".swiper-button-prev",
    nextEl: ".swiper-button-next",
    ...t.navigation !== !0 ? t.navigation : {}
  } : t.navigation === !1 && delete t.navigation, t.scrollbar ? t.scrollbar = {
    el: ".swiper-scrollbar",
    ...t.scrollbar !== !0 ? t.scrollbar : {}
  } : t.scrollbar === !1 && delete t.scrollbar, t.pagination ? t.pagination = {
    el: ".swiper-pagination",
    ...t.pagination !== !0 ? t.pagination : {}
  } : t.pagination === !1 && delete t.pagination, { params: t, passedParams: s };
}
function updateSwiper({
  swiper: e,
  slides: t,
  passedParams: s,
  changedParams: i,
  nextEl: n,
  prevEl: a,
  scrollbarEl: r,
  paginationEl: o
}) {
  const l = i.filter((k) => k !== "children" && k !== "direction" && k !== "wrapperClass"), {
    params: c,
    pagination: u,
    navigation: d,
    scrollbar: h,
    virtual: g,
    thumbs: p
  } = e;
  let m, v, f, b, E, A, C, w;
  i.includes("thumbs") && s.thumbs && s.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (m = !0), i.includes("controller") && s.controller && s.controller.control && c.controller && !c.controller.control && (v = !0), i.includes("pagination") && s.pagination && (s.pagination.el || o) && (c.pagination || c.pagination === !1) && u && !u.el && (f = !0), i.includes("scrollbar") && s.scrollbar && (s.scrollbar.el || r) && (c.scrollbar || c.scrollbar === !1) && h && !h.el && (b = !0), i.includes("navigation") && s.navigation && (s.navigation.prevEl || a) && (s.navigation.nextEl || n) && (c.navigation || c.navigation === !1) && d && !d.prevEl && !d.nextEl && (E = !0);
  const M = (k) => {
    e[k] && (e[k].destroy(), k === "navigation" ? (e.isElement && (e[k].prevEl.remove(), e[k].nextEl.remove()), c[k].prevEl = void 0, c[k].nextEl = void 0, e[k].prevEl = void 0, e[k].nextEl = void 0) : (e.isElement && e[k].el.remove(), c[k].el = void 0, e[k].el = void 0));
  };
  i.includes("loop") && e.isElement && (c.loop && !s.loop ? A = !0 : !c.loop && s.loop ? C = !0 : w = !0), l.forEach((k) => {
    if (isObject(c[k]) && isObject(s[k]))
      extend(c[k], s[k]);
    else {
      const O = s[k];
      (O === !0 || O === !1) && (k === "navigation" || k === "pagination" || k === "scrollbar") ? O === !1 && M(k) : c[k] = s[k];
    }
  }), l.includes("controller") && !v && e.controller && e.controller.control && c.controller && c.controller.control && (e.controller.control = c.controller.control), i.includes("children") && t && g && c.virtual.enabled && (g.slides = t, g.update(!0)), i.includes("children") && t && c.loop && (w = !0), m && p.init() && p.update(!0), v && (e.controller.control = c.controller.control), f && (e.isElement && (!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-pagination"), e.el.shadowEl.appendChild(o)), o && (c.pagination.el = o), u.init(), u.render(), u.update()), b && (e.isElement && (!r || typeof r == "string") && (r = document.createElement("div"), r.classList.add("swiper-scrollbar"), e.el.shadowEl.appendChild(r)), r && (c.scrollbar.el = r), h.init(), h.updateSize(), h.setTranslate()), E && (e.isElement && ((!n || typeof n == "string") && (n = document.createElement("div"), n.classList.add("swiper-button-next"), e.el.shadowEl.appendChild(n)), (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-button-prev"), e.el.shadowEl.appendChild(a))), n && (c.navigation.nextEl = n), a && (c.navigation.prevEl = a), d.init(), d.update()), i.includes("allowSlideNext") && (e.allowSlideNext = s.allowSlideNext), i.includes("allowSlidePrev") && (e.allowSlidePrev = s.allowSlidePrev), i.includes("direction") && e.changeDirection(s.direction, !1), (A || w) && e.loopDestroy(), (C || w) && e.loopCreate(), e.update();
}
const SwiperFontCSS = "@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}", SwiperCSS = ":root{--swiper-theme-color:#007aff}.swiper,swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}:host(.swiper-vertical)>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight swiper-slide{height:auto}:host(.swiper-autoheight) .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}:host(.swiper-3d.swiper-css-mode) .swiper-wrapper{perspective:1200px}:host(.swiper-3d) .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d swiper-slide{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}:host(.swiper-css-mode)>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}:host(.swiper-css-mode)>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>swiper-slide{scroll-snap-align:start start}:host(.swiper-horizontal.swiper-css-mode)>.swiper-wrapper{scroll-snap-type:x mandatory}:host(.swiper-vertical.swiper-css-mode)>.swiper-wrapper{scroll-snap-type:y mandatory}:host(.swiper-centered)>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered>swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-centered.swiper-horizontal>swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}:host(.swiper-centered.swiper-horizontal)>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}:host(.swiper-centered.swiper-vertical)>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,swiper-container:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper-virtual swiper-slide{-webkit-backface-visibility:hidden;transform:translateZ(0)}:host(.swiper-virtual.swiper-css-mode) .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}:host(.swiper-virtual.swiper-css-mode.swiper-horizontal) .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}:host(.swiper-virtual.swiper-css-mode.swiper-vertical) .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev,:host(.swiper-rtl) .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-prev:after,:host(.swiper-rtl) .swiper-button-next:after{content:'prev'}.swiper-button-next,:host(.swiper-rtl) .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-next:after,:host(.swiper-rtl) .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:50%;background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,:host(.swiper-horizontal.swiper-rtl) .swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}:host(.swiper-rtl) .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;-ms-touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move;touch-action:none}.swiper .swiper-notification,swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}:host(.swiper-free-mode)>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}:host(.swiper-grid)>.swiper-wrapper{flex-wrap:wrap}:host(.swiper-grid-column)>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode swiper-slide{transition-timing-function:ease-out}.swiper-fade swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade swiper-slide swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube swiper-slide swiper-slide{pointer-events:none}.swiper-cube.swiper-rtl swiper-slide{transform-origin:100% 0}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-next,.swiper-cube .swiper-slide-prev,.swiper-cube swiper-slide-next+swiper-slide{pointer-events:auto;visibility:visible}.swiper-cube .swiper-slide-shadow-bottom,.swiper-cube .swiper-slide-shadow-left,.swiper-cube .swiper-slide-shadow-right,.swiper-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-flip{overflow:visible}.swiper-flip swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip swiper-slide swiper-slide{pointer-events:none}.swiper-flip .swiper-slide-active,.swiper-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-flip .swiper-slide-shadow-bottom,.swiper-flip .swiper-slide-shadow-left,.swiper-flip .swiper-slide-shadow-right,.swiper-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-creative swiper-slide{-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards swiper-slide{transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}";
let globalInjectStyles = !0;
const addGlobalStyles = (e, t) => {
  let s = document.querySelector("style#swiper-element-styles");
  const i = s && s.preInit && !e;
  !e && t && t.cssLinks().forEach((n) => {
    const a = document.createElement("link");
    a.rel = "stylesheet", a.href = n, document.head.prepend(a);
  }), (!s || i) && (s = s || document.createElement("style"), s.textContent = [SwiperFontCSS, t ? t.cssStyles() : ""].join(`
`), s.id = "swiper-element-styles", s.preInit = e, document.head.prepend(s));
};
class DummyHTMLElement {
}
const ClassToExtend = typeof window > "u" || typeof HTMLElement > "u" ? DummyHTMLElement : HTMLElement;
class SwiperContainer extends ClassToExtend {
  constructor() {
    super(), this.tempDiv = document.createElement("div"), this.shadowEl = this.attachShadow({ mode: "open" });
  }
  cssStyles() {
    return [
      globalInjectStyles ? SwiperCSS : "",
      // eslint-disable-line
      ...this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : []
    ].join(`
`);
  }
  cssLinks() {
    return this.injectStylesUrls || [];
  }
  render() {
    globalInjectStyles && addGlobalStyles(!1, this);
    const t = this.cssStyles();
    t.length && (this.stylesEl = document.createElement("style"), this.stylesEl.textContent = t, this.shadowEl.appendChild(this.stylesEl)), this.cssLinks().forEach((s) => {
      if (document.querySelector(`link[href="${s}"]`))
        return;
      const n = document.createElement("link");
      n.rel = "stylesheet", n.href = s, this.shadowEl.appendChild(n);
    }), this.tempDiv.innerHTML = `
      <slot name="container-start"></slot>
      <div class="swiper-wrapper">
        <slot></slot>
      </div>
      <slot name="container-end"></slot>
      ${needsNavigation(this.passedParams) ? `
        <div class="swiper-button-prev"></div>
        <div class="swiper-button-next"></div>
      ` : ""}
      ${needsPagination(this.passedParams) ? `
        <div class="swiper-pagination"></div>
      ` : ""}
      ${needsScrollbar(this.passedParams) ? `
        <div class="swiper-scrollbar"></div>
      ` : ""}
    `, [...this.tempDiv.children].forEach((s) => {
      this.shadowEl.appendChild(s);
    });
  }
  initialize() {
    if (this.initialized)
      return;
    this.initialized = !0;
    const { params: t, passedParams: s } = getParams(this);
    this.swiperParams = t, this.passedParams = s, delete this.swiperParams.init, this.render(), this.swiper = new Swiper(this, {
      ...t,
      touchEventsTarget: "container",
      ...t.virtual ? {} : { observer: !0 },
      onAny: (i, ...n) => {
        const a = new CustomEvent(i.toLowerCase(), {
          detail: n,
          bubbles: !0,
          cancelable: !0
        });
        this.dispatchEvent(a);
      }
    });
  }
  connectedCallback() {
    if (this.init === !1 || this.getAttribute("init") === "false") {
      addGlobalStyles(!0, this);
      return;
    }
    this.initialize();
  }
  disconnectedCallback() {
    this.swiper && this.swiper.destroy && this.swiper.destroy();
  }
  updateSwiperOnPropChange(t) {
    const { params: s, passedParams: i } = getParams(this);
    this.passedParams = i, this.swiperParams = s, updateSwiper({
      swiper: this.swiper,
      passedParams: this.passedParams,
      changedParams: [attrToProp(t)],
      ...t === "navigation" && i[t] ? {
        prevEl: ".swiper-button-prev",
        nextEl: ".swiper-button-next"
      } : {},
      ...t === "pagination" && i[t] ? {
        paginationEl: ".swiper-pagination"
      } : {},
      ...t === "scrollbar" && i[t] ? {
        scrollbarEl: ".swiper-scrollbar"
      } : {}
    });
  }
  attributeChangedCallback(t, s, i) {
    this.initialized && this.updateSwiperOnPropChange(t, i);
  }
  static get observedAttributes() {
    return paramsList.filter((s) => s.includes("_")).map(
      (s) => s.replace(/[A-Z]/g, (i) => `-${i}`).replace("_", "").toLowerCase()
    );
  }
}
paramsList.forEach((e) => {
  e !== "init" && (e = e.replace("_", ""), Object.defineProperty(SwiperContainer.prototype, e, {
    get() {
      return (this.passedParams || {})[e];
    },
    set(t) {
      this.passedParams || (this.passedParams = {}), this.passedParams[e] = t, this.initialized && this.updateSwiperOnPropChange(e, t);
    }
  }));
});
class SwiperSlide extends ClassToExtend {
  constructor() {
    super(), this.tempDiv = document.createElement("div"), this.shadowEl = this.attachShadow({ mode: "open" });
  }
  render() {
    const t = this.lazy || this.getAttribute("lazy") === "" || this.getAttribute("lazy") === "true";
    if (this.tempDiv.innerHTML = "<slot />", [...this.tempDiv.children].forEach((s) => {
      this.shadowEl.appendChild(s);
    }), t) {
      const s = document.createElement("div");
      s.classList.add("swiper-lazy-preloader"), this.appendChild(s);
    }
  }
  initialize() {
    this.render();
  }
  connectedCallback() {
    this.initialize();
  }
}
const register = (e = !0) => {
  typeof window > "u" || (e || (globalInjectStyles = !1), globalInjectStyles && addGlobalStyles(!0), window.customElements.get("swiper-container") || window.customElements.define("swiper-container", SwiperContainer), window.customElements.get("swiper-slide") || window.customElements.define("swiper-slide", SwiperSlide));
};
register();
const event$1 = new Event("sq:load");
var $sq = new Squarelovin(() => window.dispatchEvent(event$1));
window.$sq = $sq;
export {
  addMediaParams as $,
  assign as A,
  set_custom_element_data_map as B,
  set_attributes as C,
  is_function as D,
  get_spread_update as E,
  run_all as F,
  empty as G,
  formatStyle as H,
  removePTag as I,
  getButtonStyles as J,
  getStylesWithHover as K,
  orientationValue as L,
  formatMansoryItems as M,
  onMount as N,
  isJsonString as O,
  HtmlTag as P,
  axios$1 as Q,
  add_resize_listener as R,
  SvelteComponent as S,
  TEMPLATES_TYPES as T,
  set_style as U,
  update_keyed_each as V,
  action_destroyer as W,
  get_spread_object as X,
  destroy_block as Y,
  svg_element as Z,
  src_url_equal as _,
  add_render_callback as a,
  POST_TYPE as a0,
  postHoverType as a1,
  removeExtraImagekitVideoParams as a2,
  isImagekit as a3,
  getPopupLayoutItems as a4,
  getCurrencySympol as a5,
  toggle_class as a6,
  GRID_TYPE_CLASS as a7,
  GRID_COLUMNS_CLASS as a8,
  GRID_TYPE_MOBILE_CLASS as a9,
  GRID_COLUMNS_MOBILE_CLASS as aa,
  POPUPS_WIDTH_CLASS as ab,
  getBluredMedia as ac,
  set_custom_element_data as ad,
  cssFilter as ae,
  beforeUpdate as af,
  getGridClasses as ag,
  subscribe as ah,
  identity as ai,
  create_slot as aj,
  update_slot_base as ak,
  get_all_dirty_from_scope as al,
  get_slot_changes as am,
  create_in_transition as an,
  create_out_transition as ao,
  set_input_value as ap,
  extractErrors as aq,
  select_value as ar,
  select_option as as,
  $sq as at,
  space as b,
  construct_svelte_component as c,
  create_component as d,
  element as e,
  insert as f,
  append as g,
  group_outros as h,
  init as i,
  destroy_component as j,
  check_outros as k,
  listen as l,
  mount_component as m,
  noop$1 as n,
  transition_in as o,
  detach as p,
  destroy_each as q,
  component_subscribe as r,
  safe_not_equal as s,
  transition_out as t,
  createEventDispatcher as u,
  globals as v,
  text as w,
  attr as x,
  set_data as y,
  translation as z
};
